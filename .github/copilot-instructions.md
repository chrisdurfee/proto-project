# Copilot Instructions

**Goal**: Enable AI agents to build resilient, scalable, maintainable, and secure code with minimal errors and without human intervention.

## 1. Project Overview & Architecture
We strive to maintain high code quality and consistency. The code should be resilient, scalable, maintainable, and secure. Functions and methods should adhere to single responsibility principle, and classes should follow SOLID principles. fail gracefully with proper error handling and logging. Database tables should be normalized to at least 3NF.

### Stack
- **Backend**: PHP 8.4 monolith using **Proto Framework**. Entry: `public/api/index.php`.
- **Frontend**: Vite-based apps in `apps/{crm,developer,main}` using **Base Framework** (fundamentally different from React/Vue).
- **Infrastructure**: Dockerized (Web/PHP, MariaDB, Redis) via `infrastructure/docker-compose.yaml`.

### Code Layout
- `modules/*`: Feature modules (domain logic). Supports nested feature modules.
- `common/*`: Shared framework glue, base classes, configs.
- `public/*`: HTTP entrypoints and assets.
- `apps/*`: Independent frontend applications proxying to backend.

### Autoloading
- PSR-4: `Modules\` → `modules/`, `Common\` → `common/`.
- Migrations: classmapped from `common/Migrations` and recursively discovered from `modules/*/Migrations` (up to 6 levels deep).

## 2. Critical Workflows

### Setup
1. Copy `common/Config/.env-example` → `common/Config/.env`.
2. Run `./infrastructure/scripts/run.sh sync-config` (generates root `.env` for Docker).

### Run Services
```bash
docker-compose -f infrastructure/docker-compose.yaml up -d
```
- **Logs**: `docker-compose -f infrastructure/docker-compose.yaml logs -f web`
- **Shell**: `docker-compose -f infrastructure/docker-compose.yaml exec web bash`

### Migrations
- **Auto-run**: Enabled by default (`AUTO_MIGRATE=true`).
- **Manual**: `docker-compose -f infrastructure/docker-compose.yaml exec web php infrastructure/scripts/run-migrations.php`

### Generator (Developer Tooling)
- **Location**: `/api/developer/generator`
- **Controller**: `Modules\Developer\Controllers\GeneratorController`
- **Purpose**: Scaffold modules, models, apis, controllers, policies, storage, migrations, gateways, and tests with consistent structure.
Pass the required parameters in the request body to generate the desired files in the local filesystem.

```curl
curl -X POST "https://localhost:8443/api/developer/generator" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  --data-urlencode 'type=module' \
  --data-urlencode 'resource={"type":"module","module":{"name":"Test"},"model":{"fields":""}}'
```

Full resources can be generated by passing a complete resource object:
```curl
curl -X POST "https://localhost:8443/api/developer/generator" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  --data-urlencode 'type=resource' \
  --data-urlencode 'resource=
{"type":"full-resource","moduleName":"Test","storage":{"connection":"default","extends":"Storage"},"model":{"extends":"Model","storage":false,"className":"Test","tableName":"tests","alias":"t","fields":"id"},"controller":{"extends":"Controller"},"namespace":""}'
```

### Frontend Development
- Navigate to app: `cd apps/{crm,developer,main}`
- Install: `npm install`
- Dev server: `npm run dev` (ports 3000/3001/3002; `/api` proxied to container at 8080)

### Testing
- **Run all**: `php vendor/bin/phpunit`
- **Suite**: `php vendor/bin/phpunit --testsuite Feature`
- **Filter**: `php vendor/bin/phpunit --filter TestName`
- **Readable output**: `php vendor/bin/phpunit --testdox`
- Tests auto-wrap in transactions; changes rollback automatically.

### Factories
- **Location**: `modules/*/Models/Factories` or `common/Models/Factories`
- **Purpose**: Generate test data for models using the Proto Simple Faker class. Check Proto composer package in `protoframework\proto\src\Tests\SimpleFaker.php` for available methods.

**CRITICAL Faker Usage**:
- ALWAYS use `$this->faker()` as a METHOD call, NOT `$this->faker` as a property
- Proto SimpleFaker has LIMITED methods compared to FakerPHP/Faker
- **Available Methods**:
  - Basic: `name()`, `firstName()`, `lastName()`, `username()`, `email()`
  - Address: `streetAddress()`, `city()`, `state()`, `stateAbbr()`, `postcode()`
  - Text: `word()`, `words()`, `sentence()`, `paragraph()`, `text()`
  - Numbers: `numberBetween()`, `floatBetween()`, `boolean()`
  - Dates: `dateTimeBetween()`, `date()`, `time()`
  - Utility: `randomElement()`, `uuid()`, `url()`, `slug()`
- **NOT Available**: `latitude()`, `longitude()`, `imageUrl()`, `optional()`, `randomFloat()`, `paragraphs()`, `dateTimeThisMonth()`
- **Replacements**:
  - `latitude()` → `floatBetween(25.0, 50.0, 6)`
  - `longitude()` → `floatBetween(-125.0, -65.0, 6)`
  - `randomFloat(2, 10, 100)` → `floatBetween(10.0, 100.0, 2)`
  - `optional(0.7)->value` → `boolean(70) ? value : null`
  - `paragraphs(3, true)` → `paragraph(3)`
  - `dateTimeThisMonth()` → `dateTimeBetween('-1 month', 'now')`

- **Usage**:
```php
// Create and persist
$user = User::factory()->create();

// Create without persisting
$user = User::factory()->make();

// Create multiple
$users = User::factory()->count(5)->create();

// With custom attributes
$user = User::factory()->create(['email' => 'test@example.com']);

// States for variations
$admin = User::factory()->admin()->create();
```

**Factory Structure**:
```php
<?php declare(strict_types=1);
namespace Modules\User\Factories;

use Proto\Models\Factory;
use Modules\User\Models\User;

class UserFactory extends Factory
{
    /**
     * Get the model class name
     *
     * @abstract
     * @return string
     */
    protected function model(): string
    {
        return User::class;
    }

    public function definition(): array
    {
        return [
            'username' => $this->faker()->userName(), // METHOD call
            'email' => $this->faker()->email(),
            'password' => password_hash('password', PASSWORD_DEFAULT),
            'firstName' => $this->faker()->firstName(),
            'lastName' => $this->faker()->lastName()
        ];
    }

    // State methods
    public function admin(): static
    {
        return $this->state(['role' => 'admin']);
    }
}
```

Add a @method comment to factory model class help the intellisense. This should be added using the "use" keyword and factory ":class" static property.

```php
use Modules\User\Models\Factories\UserFactory;

/**
 * User model
 * @method static UserFactory factory(int $count = 1, array $attributes = [])
*/
class User extends Model
{
    /**
     * @var string|null $factory the factory class name
     */
    protected static ?string $factory = UserFactory::class;

    // ...
}
```

### Seeders
- **Location**: `modules/*/Seeders` or `common/Seeders`
- **Purpose**: Populate database with initial/test data
- **Run**: `php vendor/bin/phpunit --filter SeederTest` or programmatically
- **Usage**:
```php
// In tests or setup scripts
$seeder = new UserSeeder();
$seeder->run();

// Via SeederManager
SeederManager::run([UserSeeder::class, GroupSeeder::class]);
```

**Seeder Structure**:
```php
<?php declare(strict_types=1);
namespace Modules\User\Seeders;

use Proto\Database\Seeders\Seeder;
use Modules\User\Factories\UserFactory;

class UserSeeder extends Seeder
{
    public function run(): void
    {
        // Using factories
        User::factory()->count(10)->create();

        // Or direct creation
        User::create((object)[
            'username' => 'admin',
            'email' => 'admin@example.com',
            'password' => password_hash('admin123', PASSWORD_DEFAULT)
        ]);
    }
}
```

### File Storage (Vault)
- **Location**: `Proto\Utils\Files\Vault`
- **Config**: `common/Config/.env` under `"files"` key
- **Purpose**: Handle file uploads, storage, retrieval, and deletion
- **Drivers**: `local`, `s3`

**Configuration Example**:
```json
"files": {
    "local": {
        "path": "/common/files/",
        "attachments": {
            "path": "/common/files/attachments/"
        }
    },
    "amazon": {
        "s3": {
            "bucket": {
                "uploads": {
                    "secure": true,
                    "name": "main",
                    "path": "main/",
                    "region": "",
                    "version": "latest"
                }
            }
        }
    }
}
```

### File Upload Handling

**CRITICAL**: Use Request methods to access uploaded files, NOT `$_FILES` directly.

**Accessing Files**:
```php
use Proto\Http\Router\Request;
use Proto\Http\UploadFile;

// Single file upload
$avatar = $request->file('avatar'); // Returns UploadFile|null

// Multiple files (array upload like attachments[])
$attachments = $request->fileArray('attachments'); // Returns UploadFile[]

// All uploaded files
$allFiles = $request->files(); // Returns array keyed by input name
```

**Validation with UploadFile Objects**:
```php
// In controller - validate before storing
public function upload(Request $request): object
{
    $data = [
        'name' => $request->input('name'),
        'avatar' => $request->file('avatar') // UploadFile object
    ];

    $rules = [
        'name' => 'string:100|required',
        'avatar' => 'image:2048|required|mimes:jpeg,png'
    ];

    $this->validateRules($data, $rules);

    // Store validated file
    $data['avatar']->store('local', 'avatars');
    return $this->success(['filename' => $data['avatar']->getNewName()]);
}

// With file arrays
public function uploadMultiple(Request $request): object
{
    $attachments = $request->fileArray('attachments');

    foreach ($attachments as $file)
    {
        // Validate each file
        $validator = Validator::create(['file' => $file], [
            'file' => 'image:5120|mimes:jpeg,png,gif'
        ]);

        if ($validator->isValid())
        {
            $file->store('local', 'attachments');
        }
    }

    return $this->success(['count' => count($attachments)]);
}
```

**Request File Validation Methods**:
```php
// Validate single file with rules
$avatar = $request->validateFile('avatar', [
    'avatar' => 'image:2048|required|mimes:jpeg,png'
]);

// Validate file array
$attachments = $request->validateFileArray('attachments', [
    'attachments' => 'file:5120|mimes:pdf,doc,docx'
]);
```

### Storage Operations
```php
use Proto\Utils\Files\Vault;
use Proto\Http\UploadFile;

// In controller - store uploaded file
$uploadFile = $request->file('upload');
$uploadFile->store('local', 'attachments');

// Get file metadata
$originalName = $uploadFile->getOriginalName();
$newName = $uploadFile->getNewName();
$size = $uploadFile->getSize();
$mimeType = $uploadFile->getMimeType();

// Image-specific methods
if ($uploadFile->isImageFile())
{
    [$width, $height] = $uploadFile->getDimensions();
}

// Via Vault directly
Vault::disk('local', 'attachments')->add('/tmp/file.txt');

// Download file
Vault::disk('local', 'attachments')->download('file.txt');

// Get file content
$content = Vault::disk('local')->get('/tmp/file.txt');

// Delete file
Vault::disk('local')->delete('/tmp/file.txt');

// S3 usage
Vault::disk('s3', 'uploads')->add('/tmp/file.txt');
Vault::disk('s3')->delete('/tmp/file.txt');
```

## 3. Backend Development (Proto Framework)

### Code Style (CRITICAL)
Always use doc blocks for classes, properties, members, functions, types, and methods.

#### Strict Types
**ALWAYS** declare strict types:
```php
<?php declare(strict_types=1);
```

#### Braces
**Opening braces ALWAYS on new line** (methods, classes, if/else, loops):
```php
// ✅ CORRECT
public function getUserCars(int $userId): array
{
    return CarProfile::fetchWhere(['userId' => $userId]);
}

if ($condition)
{
    // code
}

// ❌ WRONG
public function getUserCars(int $userId): array {
    return CarProfile::fetchWhere(['userId' => $userId]);
}
```

### References
**CRITICAL**: ALWAYS use the "use" statement for class references at the top of the file, NOT fully qualified names inline. This applies to ALL contexts including method parameters, return types, builder methods, and static calls.

```php
// ✅ CORRECT - Import at top of file
use Modules\User\Models\User;
use Modules\Post\Media\Models\PostMedia;

// Then use short class names
$user = User::get($userId);
$class = User::class;

// In model joins
$builder->hasMany(PostMedia::class, 'postId', 'id', 'media');

// In type hints
public function getUser(User $user): User
{
    return $user;
}

// In model properties (factory, etc.)
protected static ?string $factory = PostFactory::class;

// ❌ WRONG - Inline fully qualified names
$user = \Modules\User\Models\User::get($userId);
$class = \Modules\User\Models\User::class;

// ❌ WRONG - In builder methods
$builder->hasMany(\Modules\Post\Media\Models\PostMedia::class, 'postId', 'id', 'media');

// ❌ WRONG - In type hints
public function getUser(\Modules\User\Models\User $user): \Modules\User\Models\User
```

**Key Rule**: If you need to reference a class, add it to the use statements at the top of the file FIRST, then use the short name everywhere in the file.

#### Spacing
use tabs for indentation, 4 spaces for alignment.

**NO blank lines** between variable assignment and immediate condition check:
```php
// ✅ CORRECT
$carProfile = CarProfile::get($carProfileId);
if (!$carProfile)
{
    return false;
}

// ❌ WRONG
$carProfile = CarProfile::get($carProfileId);

if (!$carProfile)
{
    return false;
}
```

### Modules

**Location**: `modules/YourModule/YourModuleModule.php`

**Structure**:
```php
<?php declare(strict_types=1);

namespace Modules\YourModule;

use Proto\Module\Module;

class YourModuleModule extends Module
{
    public function activate(): void
    {
        // Setup code
    }
}
```

**CRITICAL**:
- Extend `Proto\Module\Module` (singular, NOT `Proto\Modules\Module`)
- Use `activate()` method NOT `boot()`
- Routes automatically loaded from `modules/*/Api/api.php`

### Nested Feature Modules

Proto supports nested feature modules within parent modules for better organization of large modules with many related features.

**Directory Structure**:

```
modules/
  Community/
    CommunityModule.php           # Parent module class
    Main/                          # Root-level module code (optional)
      Api/
        api.php                    # Handles /api/community
      Controllers/
      Models/
    Group/                         # Nested feature
      Api/
        api.php                    # Handles /api/community/group
        Settings/
          api.php                  # Handles /api/community/group/settings
      Controllers/
      Models/
      Migrations/
      Services/
    Events/                        # Another nested feature
      Api/
        api.php                    # Handles /api/community/events
      Controllers/
      Models/
    Gateway/
      Gateway.php                  # Parent gateway with feature access
```

**The "Main" Folder Convention**:
For modules that need both root-level functionality AND nested features, use a `Main/` folder:

```
modules/
  User/
    UserModule.php
    Main/                          # Root user functionality
      Api/
        api.php                    # /api/user
      Controllers/
        UserController.php
      Models/
        User.php
    Profile/                       # Nested feature
      Api/
        api.php                    # /api/user/profile
    Settings/                      # Another nested feature
      Api/
        api.php                    # /api/user/settings
```

**URL Resolution Order**:
1. **Nested Feature**: `modules/{Seg1}/{Seg2}/Api/{Seg3...}/api.php`
2. **Nested Feature with Main**: `modules/{Seg1}/{Seg2}/Main/Api/{Seg3...}/api.php`
3. **Flat Module**: `modules/{Seg1}/Api/{Seg2...}/api.php`
4. **Main Folder Fallback**: `modules/{Seg1}/Main/Api/{Seg2...}/api.php`
5. **Recursive Fallback**: Try parent paths if specific file not found

**URL Resolution Examples**:

| URL | Resolution Path |
|-----|----------------|
| `/api/community/group` | `modules/Community/Group/Api/api.php` |
| `/api/community/group/settings` | `modules/Community/Group/Api/Settings/api.php` |
| `/api/community/group/forum` | `modules/Community/Group/Forum/Api/api.php` |
| `/api/user` | `modules/User/Api/api.php` OR `modules/User/Main/Api/api.php` |
| `/api/user/profile` | `modules/User/Profile/Api/api.php` |

**Gateway Access Pattern**:
Parent gateways expose child features as methods AND include main functionality directly.

**CRITICAL Gateway Rules**:
1. **Main module methods are direct** - Core CRUD operations on parent gateway (e.g., `modules()->user()->get()`)
2. **Nested features use accessor methods** - Sub-features accessed via methods (e.g., `modules()->user()->follower()`)
3. **No separate main() accessor** - Don't require `modules()->user()->main()->get()`, put directly on parent gateway

```php
// modules/User/Gateway/Gateway.php
<?php declare(strict_types=1);

namespace Modules\User\Gateway;

use Modules\User\Main\Models\User;
use Modules\User\Main\Services\NewUserService;
use Modules\User\Follower\Gateway\Gateway as FollowerGateway;
use Modules\User\Role\Gateway\Gateway as RoleGateway;

class Gateway
{
    // ✅ CORRECT - Main User methods directly on gateway
    public function get(mixed $id): ?User
    {
        return User::get($id);
    }

    public function create(object $settings): User
    {
        $model = new User($settings);
        $model->add();
        return $model;
    }

    public function authenticate(string $username, string $password): int
    {
        return User::authenticate($username, $password);
    }

    // ✅ CORRECT - Nested features via accessor methods
    public function follower(): FollowerGateway
    {
        return new FollowerGateway();
    }

    public function role(): RoleGateway
    {
        return new RoleGateway();
    }
}

// ❌ WRONG - Don't create main() accessor
public function main(): MainGateway
{
    return new MainGateway();
}
```

**Usage**:
```php
// ✅ CORRECT - Main methods directly
$user = modules()->user()->get($userId);
$user = modules()->user()->create($data);
modules()->user()->authenticate($username, $password);

// ✅ CORRECT - Nested features via accessor
modules()->user()->follower()->follow($userId, $targetId);
modules()->user()->role()->assign($userId, $roleId);

// ❌ WRONG - Don't require main() accessor
$user = modules()->user()->main()->get($userId);
```

**Community Example**:
```php
// modules/Community/Gateway/Gateway.php
class Gateway
{
    // Main Community methods (if any) go directly here
    public function get(int $id): ?Community { ... }

    // Nested features via accessors
    public function group(): GroupGateway
    {
        return new GroupGateway();
    }

    public function events(): EventsGateway
    {
        return new EventsGateway();
    }
}

// Usage
modules()->community()->group()->addMember($userId, $groupId);
```

**Feature Namespacing** (PSR-4):
```php
// modules/Community/Group/Models/Group.php
namespace Modules\Community\Group\Models;

use Proto\Models\Model;

class Group extends Model
{
    // ...
}

// modules/Community/Group/Controllers/GroupController.php
namespace Modules\Community\Group\Controllers;

use Proto\Controllers\ResourceController;
use Modules\Community\Group\Models\Group;

class GroupController extends ResourceController
{
    public function __construct(protected ?string $model = Group::class)
    {
        parent::__construct();
    }
}
```

**Feature API Routes**:
```php
// modules/Community/Group/Api/api.php
<?php declare(strict_types=1);

use Modules\Community\Group\Controllers\GroupController;
use Modules\Community\Group\Controllers\MemberController;

// Resource routes for /api/community/group
router()->resource('community/group', GroupController::class);

// Nested resource for /api/community/group/:groupId/member
router()->resource('community/group/:groupId/member', MemberController::class);
```

**Migrations in Nested Features**:
Migrations are discovered recursively throughout the module structure (up to 6 levels deep):
- `modules/Community/Migrations/`
- `modules/Community/Group/Migrations/`
- `modules/Community/Group/Forum/Migrations/`

**When to Use Nested Features**:
- Module has 3+ distinct sub-domains
- Features are self-contained with own Controllers, Models, Services
- Want to organize large modules hierarchically

**CRITICAL**:
- Parent modules registered as usual in config - nested features automatically available
- Existing flat modules continue to work (backward compatible)
- Keep features self-contained - each with its own Controllers, Models, Services
- Share functionality via parent Gateway methods
- Migrations per feature - keep in the feature that owns the tables

### Routing

**Location**: `modules/YourModule/Api/api.php`

The Proto ApiRouter will automatically add an `id` parameter at the end of the path for item-specific actions using a resource route.
```php
use Modules\User\Controllers\UserController;
// in Modules/User/Api/api.php
// path: /user/:id?
router()->resource('user', UserController::class);

// in Modules/User/Api/Address/api.php
// path: /user/:userId/address/:id?
router()->resource('user/:userId/address', AddressController::class);
```

**Patterns**:
```php
// Resource routes
use Modules\User\Controllers\UserController;
router()->resource('user', UserController::class);

// Custom routes (use array callable)
router()->get('user/stats', [UserController::class, 'stats']);

// Fluent chaining
router()
    ->get('garage/portfolio', [GarageController::class, 'portfolio'])
    ->post('garage/reorder', [GarageController::class, 'reorder'])
    ->resource('garage', GarageController::class); // The resource route must be last to allow other routes to take precedence

// Groups
// use router groups if the routes share a common prefix to reduce the amount of repetition
router()->group('auth/crm', function(Router $router)
{
    $router->post('login', [AuthController::class, 'login']);
    $router->post('mfa/verify', [AuthController::class, 'verifyAuthCode']);
});
```

**Middleware**:
After a router middleware is applied in a file, it applies to all routes defined in that file that are listed after the middleware call.

```php
use Proto\Http\Middleware\CrossSiteProtectionMiddleware;
use Proto\Http\Middleware\ApiRateLimiterMiddleware;

router()
    // router level middleware applied to all routes after this line in this file including other router() calls
    ->middleware([CrossSiteProtectionMiddleware::class])

    // route level middleware applied to specific route
    ->get('user/account', [UserController::class, 'account'],
    [
        ApiRateLimiterMiddleware::class,
        AnotherMiddleware::class
    ]);
```

**CRITICAL**:
- Module routes MUST start with module name: `'garage/...'` NOT `'user/:id/garage/...'`
- Controller methods: ALWAYS wrap in array `[Controller::class, 'method']`
- Use fluent interface for chaining
- Controllers should use Auth Policies for authentication/authorization. The controller methods should not be checking for authentication directly.

### Controllers

**Base Classes**:
- `Proto\Controllers\ResourceController` (CRUD)
- `Proto\Controllers\ApiController` (custom endpoints)

**Example**:
```php
use Modules\User\Main\Auth\Policies\UserPolicy;

class UserController extends ResourceController
{
    protected ?string $policy = UserPolicy::class;

    public function __construct(protected ?string $model = User::class)
    {
        parent::__construct();
    }

    protected function validate(): array
    {
        return [
            'name' => 'string:255|required',
            'email' => 'email|required',
            'firstName' => 'string:100'
        ];
    }
}
```
***Route Requests***:
Controllers receive `use Proto\Http\Router\Request` objects in public methods and hook methods.

***Exceptions**:
Do not throw exceptions in controllers. Use `$this->setError('message')` in hook methods or `$this->error('message')` in public methods to fail gracefully.
```php
// ✅ CORRECT - Graceful error handling in hook
protected function modifyUpdateItem(object &$data, Request $request): void
{
    $post = GroupPost::get($data->id);
    if (!$post)
    {
        $this->setError('Post not found');
        return;
    }

    $userId = session()->user->id;
    if ($userId)
    {
        $data->modifiedBy = $userId;
    }
}

// ✅ CORRECT - Graceful error handling in public method
public function customAction(Request $request): object
{
    $id = $request->getInt('id');
    if (!$id)
    {
        return $this->error('ID required');
    }
    // ...
}

// ❌ WRONG - Throwing exceptions
protected function modifyUpdateItem(object &$data, Request $request): void
{
    if (!$post)
    {
        throw new \Exception('Post not found');
    }
}
```

**Session Access**:
The api router sets up global session access:
```php
// get user from session
$user = session()->user ?? null;
$userId = session()->user->id ?? null;

//or
getSession('user');

// set session value
setSession('key', 'value');
```

**CRITICAL Authentication Pattern**:
- **Policies handle authentication** - Use `protected ?string $policy = YourPolicy::class;` in controllers
- **Controllers assume user authenticated** - After policy check, `session()->user->id` is available
- **DO NOT check auth in controllers** - No `if (!$userId)` checks needed
- **Use session data directly** - `$userId = session()->user->id;` (no null check)

```php
// ✅ CORRECT - Policy enforces auth, controller uses session
class GroupController extends ResourceController
{
    protected ?string $policy = GroupPolicy::class;

    public function join(Request $request): object
    {
        $groupId = $request->getInt('groupId');
        $userId = session()->user->id; // Safe after policy check

        return $this->service->joinGroup($userId, $groupId);
    }
}

// ❌ WRONG - Don't check auth in controller
public function join(Request $request): object
{
    $userId = session()->user->id ?? null;
    if (!$userId)
    {
        return $this->error('User not authenticated');
    }
    // ...
}
```

Controllers can access the session to inject user data into add/update operations using hook methods.


**CRITICAL**:
- Controllers NEVER access storage classes directly
- Always use model methods: `$car = CarProfile::get($id)` NOT `$storage->get($id)`
- Use validation: `$this->validateRules($data, [...])` or `$request->validate([...])`

The validate method is called by the default add or update methods in the ResrouceController to validate the data before passing it to the protected addItem or updateItem methods.

#### ResourceController Request Patterns
The resource controller provides default implementations for common CRUD operations.

**CRITICAL: Method Signatures**

**Public Methods** (receive `Request $request` parameter):
- `add(Request $request)` → calls `addItem(object $data)`
- `update(Request $request)` → calls `updateItem(object $data)`
- `delete(Request $request)` → calls `deleteItem(object $data)`
- `get(Request $request)`, `all(Request $request)`, `search(Request $request)`, etc.

The all method is used to list multiple items with optional filtering, sorting, and pagination
and can use cursor for sorting.

it accepts a filter object, optional offset and limit or last cursor and since for pagination, dates object, and optional modifiers for sorting, groupingsearching, and cursor.

This method can reduce the number of custom queries in models needed for listing endpoints.

```php
public function all(Request $request): object
{
    $inputs = $this->getAllInputs($request);
    $result = $this->model::all($inputs->filter, $inputs->offset, $inputs->limit, $inputs->modifiers);
    return $this->response($result);
}
```

**Protected Methods** (NO Request parameter):
- `addItem(object $data)` - performs the actual add operation
- `updateItem(object $data)` - performs the actual update operation
- `deleteItem(object $data)` - performs the actual delete operation

**Hook Methods** (receive `Request $request` parameter):
- `modifyAddItem(object &$data, Request $request)` - called BEFORE `addItem()`, modifies data by reference
- `modifyUpdateItem(object &$data, Request $request)` - called BEFORE `updateItem()`, modifies data by reference
- `modifyFilter(?object $filter, Request $request)` - called in `all()` to customize filter

**Access Route Parameters**:
Use Request object methods to access route input parameters. Available methods by type:
- `input($key)` - Get string parameter
- `getInt($key)` - Get integer parameter
- `getBool($key)` - Get boolean parameter
- `json($key)` - Get JSON parameter
- `raw($key)` - Get raw parameter

**CRITICAL**: `route()` method does NOT exist. Use the methods above.
- The case should be camelCase for parameters in the route path and data keys in the resource objects.

```php
// ✅ CORRECT
$communityId = $request->getInt('communityId');
$name = $request->input('name');
$isActive = $request->getBool('active');

// ❌ WRONG - route() doesn't exist
$communityId = $request->route('communityId');
```
**Params in the url**
The route parameters that are found in the request uri are available in the request object using the params method. This will return an object with the route parameters as properties.

```php
// ✅ CORRECT
// path /communities/:communityId/groups
$params = $request->params();
$communityId = (int)($params->communityId ?? 0);

// ❌ WRONG - route() doesn't exist
$communityId = $request->route('communityId');
```

```php
// ❌ WRONG - Accessing request in protected method like addItem()
protected function addItem(object $data): object
{
    $communityId = $this->request->input('communityId'); // request not available
    // ...
}

// ✅ CORRECT Option 1: Use hook method which is preferred as this allows the defaluts to do their work
protected function modifyAddItem(object &$data, Request $request): void
{
    $communityId = $request->getInt('communityId');
    if (!$communityId)
    {
        $this->setError('Community ID required');
        return;
    }

    $data->id = $this->getResourceId($request);
    $data->communityId = (int)$communityId;
}

// ✅ CORRECT Option 2: Override public method, good but the default methods do a lot of work
public function add(Request $request): object
{
    $communityId = $request->getInt('communityId');
    if (!$communityId)
    {
        return $this->error('Community ID required');
    }

    $data = $this->getRequestItem($request);
    if (empty($data))
    {
        return $this->error('No item provided.');
    }

    $file = $request->file('file');

    $data->communityId = (int)$communityId;
    $this->modifyAddItem($data, $request);
    if (!$this->validateItem($data, false))
    {
        return $this->error('Invalid item data.');
    }

    return $this->addItem($data);
}

// ✅ CORRECT Option 3: Create custom endpoint
public function create(Request $request): object
{
    $communityId = $request->getInt('communityId');
    if (!$communityId)
    {
        return $this->error('Community ID required');
    }

    $userId = session()->user->id ?? null;

    $data = $this->getRequestItem($request);
    $group = $this->service->createGroup(
        (int)$userId,
        (int)$communityId,
        $data
    );

    if (!$group)
    {
        return $this->error('Failed to create group');
    }

    return $this->response($group);
}
```

**Hook Method Examples**:

```php
use Proto\Utils\Strings;

// Add route parameter to data
protected function modifyAddItem(object &$data, Request $request): void
{
    $clientId = $request->getInt('clientId');
    if ($clientId)
    {
        $data->clientId = $clientId;
    }

    // Sanitize content
    if (isset($data->content))
    {
        $data->content = Strings::prepareContent($data->content);
    }
}

// Restrict fields that shouldn't be modified
protected function modifyUpdateItem(object &$data, Request $request): void
{
    $id = $data->id ?? null;
    $restrictedFields = ['id', 'clientId', 'createdAt', 'createdBy'];
    $this->restrictFields($data, $restrictedFields);
    $data->id = $id; // Restore ID after restriction
}

// Modify filter for all() queries
protected function modifyFilter(?object $filter, Request $request): ?object
{
    $clientId = $request->getInt('clientId');
    if ($clientId)
    {
        $filter->clientId = (int)$clientId;
    }
    return $filter;
}
```

**When to Use Each Pattern**:

1. **Use hook methods** (`modifyAddItem`, `modifyUpdateItem`) when:
   - Injecting route parameters into data
   - Sanitizing/transforming input data
   - Setting default values
   - Restricting fields

2. **Override public methods** (`add`, `update`) when:
   - Need complex validation based on route parameters
   - Need to call services with custom logic
   - Need to return custom responses
   - Need multiple DB operations

3. **Override protected methods** (`addItem`, `updateItem`) when:
   - Customizing the persistence logic itself
   - Adding post-persistence operations
   - NOT for accessing request data (use hooks instead)

### Models

**Base**: `Proto\Models\Model`

**Static Methods** (operate on class):
- `create((object)$data)` - returns BOOL
- `get($id)` - returns object|null
- `remove($id)` - returns bool
- `fetchWhere([...])` - returns array

**Instance Methods** (operate on object):
- `add()` - persists new instance
- `update()` - updates existing
- `delete()` - removes instance

**Configuration**:
```php
class User extends Model
{
    protected static ?string $tableName = 'users';
    protected static ?string $alias = 'u';

    // camelCase fields that get converted to snake_case in storage layer
    protected static array $fields = ['id', 'name', 'email', 'status'];
    protected static array $fieldsBlacklist = ['password']; // Exclude from JSON output (optional)
    protected static string $idKeyName = 'id'; // Default, only set if different

    // Pre-persist hook - sanitize/transform before save (optional)
    protected static function augment(mixed $data = null): mixed
    {
        if ($data && isset($data->email))
        {
            $data->email = strtolower(trim($data->email));
        }
        return $data;
    }

    // Post-fetch hook - shape API output (optional)
    protected static function format(?object $data): ?object
    {
        if ($data)
        {
            $data->displayName = $data->firstName . ' ' . $data->lastName;
        }
        return $data;
    }
}
```

### Model Relationships: Eager vs Lazy

Proto supports two distinct approaches to relating models:

**1. Eager Joins (JoinBuilder)** - Loaded in single query via SQL JOIN
**2. Lazy Relationships** - Loaded on-demand via separate queries

#### Eager Joins (JoinBuilder)

**WHEN TO USE**: When you ALWAYS need related data and want to avoid N+1 queries.

**Define in `joins()` method** using JoinBuilder API:

```php
protected static function joins(object $builder): void
{
    // One-to-one join
    Role::one($builder)
        ->on(['id', 'userId'])  // [parent_key, foreign_key]
        ->fields('role');  // Fields to select from roles table

    // One-to-many through bridge table
    UserRole::bridge($builder)
        ->many(Role::class)
        ->on(['roleId', 'id'])
        ->fields('id', 'name', 'slug', 'description', 'permissions');

    // belongsTo (inverse one-to-one)
    $builder->belongsTo(Organization::class, fields: ['name', 'slug']);

    // Raw table join
    $builder->left('permission', 'p')
        ->on(['id', 'permissionId'])
        ->fields('name');
}
```

**BelongsToMany Chaining Pattern**:
For complex many-to-many relationships, chain `belongsToMany` calls:

```php
protected static function joins(object $builder): void
{
    // Chain 1: User → Roles → Permissions
    // Joins user_roles, then roles, then permission_roles, then permissions
    $builder
        ->belongsToMany(Role::class, pivotFields: ['organizationId'])
        ->belongsToMany(Permission::class);

    // Chain 2: User → Organizations
    // Joins organization_users, then organizations
    $builder
        ->belongsToMany(Organization::class, ['id', 'name']);
}
```

**Key Points**:
- `on()` takes `[parent_key, foreign_key]` order
- `fields()` specifies which columns to select from related table
- EXCLUDE 'id' from `fields()` in `belongsTo` to avoid conflicts
- Use named parameters: `fields: ['name']` NOT positional
- Chained `belongsToMany` automatically handles pivot tables

#### Lazy Relationships

**WHEN TO USE**: When related data is optional or conditionally needed.

**Define as methods** returning relation objects:

```php
class User extends Model
{
    // One-to-many: User has many posts
    public function posts(): \Proto\Models\Relations\HasMany
    {
        return $this->hasMany(Post::class);
    }

    // One-to-one: User has one profile
    public function profile(): \Proto\Models\Relations\HasOne
    {
        return $this->hasOne(Profile::class);
    }

    // Many-to-many: User has many roles through user_roles pivot
    public function roles(): \Proto\Models\Relations\BelongsToMany
    {
        // Params: related model, pivot table, foreign pivot key, related pivot key, parent key, related key
        return $this->belongsToMany(
            Role::class,
            'user_roles',  // pivot table (optional, auto-inferred)
            'user_id',     // foreign key in pivot (optional)
            'role_id',     // related key in pivot (optional)
            'id',          // parent key (optional)
            'id'           // related key (optional)
        );
    }
}

class Post extends Model
{
    // Belongs-to (inverse): Post belongs to user
    public function user(): \Proto\Models\Relations\BelongsTo
    {
        return $this->belongsTo(User::class);
    }
}
```

**Usage**:
```php
// Eager join: All data in one query
$user = User::get(1); // Includes eager-joined roles automatically

// Lazy load: Separate queries fired on access
$user = User::get(1);
$posts = $user->posts;     // SELECT * FROM posts WHERE user_id = 1
$profile = $user->profile; // SELECT * FROM profiles WHERE user_id = 1
$roles = $user->roles;     // SELECT * FROM roles r INNER JOIN user_roles p...
```

**BelongsToMany Helper Methods**:
```php
// Attach role to user (add pivot record)
$user->roles()->attach(3);

// Detach role from user (remove pivot record)
$user->roles()->detach(3);

// Sync roles (remove non-matching, add missing)
$user->roles()->sync([2, 4, 5]);

// Toggle roles (attach if missing, detach if present)
$user->roles()->toggle([2, 6]);
```

#### Combining Both Approaches

You can use BOTH eager and lazy relationships in the same model:

```php
class User extends Model
{
    // Eager join for organization (always needed)
    protected static function joins(object $builder): void
    {
        $builder->belongsTo(Organization::class, fields: ['name', 'slug']);
    }

    // Lazy relationship for posts (conditionally needed)
    public function posts(): \Proto\Models\Relations\HasMany
    {
        return $this->hasMany(Post::class);
    }

    // Lazy relationship for profile (conditionally needed)
    public function profile(): \Proto\Models\Relations\HasOne
    {
        return $this->hasOne(Profile::class);
    }
}
```

#### Common Errors to Avoid

```php
// ❌ WRONG - Including 'id' in belongsTo fields causes conflicts
$builder->belongsTo(Organization::class, fields: ['id', 'name']);

// ✅ CORRECT - Exclude 'id' field
$builder->belongsTo(Organization::class, fields: ['name', 'slug']);

// ❌ WRONG - Wrong parameter order in on()
Role::one($builder)->on(['roleId', 'id']); // Wrong order

// ✅ CORRECT - [parent_key, foreign_key]
Role::one($builder)->on(['id', 'userId']);

// ❌ WRONG - Missing fields() call
Role::one($builder)->on(['id', 'userId']); // No fields selected

// ✅ CORRECT - Always specify fields
Role::one($builder)->on(['id', 'userId'])->fields('role', 'name');

// ❌ WRONG - Using positional parameters instead of named
$builder->belongsTo(Organization::class, ['name', 'slug']);

// ✅ CORRECT - Use named parameter 'fields:'
$builder->belongsTo(Organization::class, fields: ['name', 'slug']);

// ❌ WRONG - Defining joins() method with lazy relationships syntax
protected static function joins(object $builder): void
{
    return $this->hasMany(Post::class); // Wrong context
}

// ✅ CORRECT - Use JoinBuilder methods in joins()
protected static function joins(object $builder): void
{
    $builder->belongsTo(Category::class, fields: ['name']);
}

// ❌ WRONG - Trying to use JoinBuilder methods outside joins()
public function posts()
{
    Post::one($this)->fields('title'); // Wrong approach
}

// ✅ CORRECT - Use relationship methods for lazy loading
public function posts(): \Proto\Models\Relations\HasMany
{
    return $this->hasMany(Post::class);
}
```

**CRITICAL**:
- `create()` takes OBJECT not array: `User::create((object)['name' => 'John'])`
- `create()` returns BOOL not object. Use instance approach to track:
  ```php
  $user = new User();
  $user->name = 'John';
  $user->add(); // now $user->id is available
  ```
- Use constructor with object for efficiency:
  ```php
  // ✅ CORRECT
  $user = new User((object)$data);
  $user->add();

  // ✅ CORRECT - Direct object
  $user = new User((object)[
        'name' => 'John',
        'email' => 'john@example.com'
  ]);
  $user->add();

  // ❌ WRONG - Verbose and unnecessary
  $user = new User();
  foreach ($data as $key => $value)
  {
      $user->$key = $value;
  }
  $user->add();

  // ❌ WRONG - Verbose and unnecessary
  $user = new User();
  $user->name = $data['name'];
  $user->email = $data['email'];
  $user->add();
  ```
- `delete()` is instance method NOT static:
  - ❌ WRONG: `User::delete(5)`
  - ✅ CORRECT: `User::remove(5)` or `$user = User::get(5); $user->delete();`
- **Eager joins**: Define in `joins()` method using JoinBuilder (`Role::one()`, `->belongsTo()`, etc.)
- **Lazy relationships**: Define as public methods returning `HasMany`, `HasOne`, `BelongsTo`, or `BelongsToMany`
- In eager `belongsTo`: ALWAYS use named parameter `fields: [...]` and EXCLUDE 'id' field
- In eager joins: `on()` order is `[parent_key, foreign_key]`

### Custom Data Types (Geo Points, JSON, etc.)

**Overview**: Proto supports custom data type handlers for complex SQL types like POINT, JSON, GEOMETRY, and more. This eliminates the need for custom Storage classes to handle special SQL placeholders and parameter binding.

**Benefits**:
- Declaratively handle complex SQL types using `$dataTypes` property
- Automatic placeholder generation and parameter binding
- Support for multiple input formats (string, array, object)
- Zero boilerplate in Storage classes

#### Geographic Data (POINT)

**WHEN TO USE**: Storing latitude/longitude coordinates using MySQL's POINT spatial type.

**Model Configuration**:
```php
<?php declare(strict_types=1);
namespace Modules\Auth\Models;

use Proto\Models\Model;
use Proto\Storage\DataTypes\PointType;

class UserAuthedLocation extends Model
{
    protected static ?string $tableName = 'user_authed_locations';

    protected static array $fields = [
        'id',
        'city',
        'position',
        [['X(`position`)'], 'latitude'],  // Extract X coordinate
        [['Y(`position`)'], 'longitude'], // Extract Y coordinate
    ];

    /**
     * Map field names to DataType handlers
     */
    protected static array $dataTypes = [
        'position' => PointType::class
    ];
}
```

**Usage Examples**:
```php
$location = new UserAuthedLocation();

// String format (space-separated lat/lon)
$location->position = '37.7749 -122.4194';
$location->city = 'San Francisco';
$location->add(); // Automatically converts to POINT(?, ?)

// Array format
$location->position = [37.7749, -122.4194];
$location->add();

// Object format
$location->position = (object)['lat' => 37.7749, 'lon' => -122.4194];
$location->add();

// Update works the same way
$location = UserAuthedLocation::get(1);
$location->position = '37.8044 -122.2712'; // Berkeley
$location->update(); // Automatically handles SET position = POINT(?, ?)

// Querying by location (if needed, in custom Storage)
$nearbyLocations = UserAuthedLocation::fetchWhere([
    ["ST_Distance_Sphere(position, POINT(?, ?)) < ?", [-122.4194, 37.7749, 10000]]
]);
```

#### JSON Data

**WHEN TO USE**: Storing metadata, settings, or configuration as JSON.

**Model Configuration**:
```php
<?php declare(strict_types=1);
namespace Modules\Events\Models;

use Proto\Models\Model;
use Proto\Storage\DataTypes\JsonType;

class Event extends Model
{
    protected static array $fields = [
        'id',
        'name',
        'metadata',
        'settings',
        'tags'
    ];

    protected static array $dataTypes = [
        'metadata' => JsonType::class,
        'settings' => JsonType::class,
        'tags' => JsonType::class
    ];
}
```

**Usage**:
```php
$event = new Event();
$event->name = 'Conference 2026';
$event->metadata = ['speakers' => ['John', 'Jane'], 'capacity' => 500];
$event->tags = ['tech', 'conference', 'ai'];
$event->add(); // Arrays automatically encoded to JSON strings
```

#### Multiple Custom Types

You can mix multiple custom data types in a single model:

```php
<?php declare(strict_types=1);
namespace Modules\Events\Models;

use Proto\Models\Model;
use Proto\Storage\DataTypes\PointType;
use Proto\Storage\DataTypes\JsonType;

class Location extends Model
{
    protected static array $fields = [
        'id',
        'name',
        'coordinates',   // POINT type
        'metadata',      // JSON type
        'properties',    // JSON type
        [['X(`coordinates`)'], 'latitude'],
        [['Y(`coordinates`)'], 'longitude']
    ];

    protected static array $dataTypes = [
        'coordinates' => PointType::class,
        'metadata' => JsonType::class,
        'properties' => JsonType::class
    ];
}
```

**CRITICAL**:
- Declare custom types in `protected static array $dataTypes = [...]`
- Use `PointType::class` for geographic coordinates (POINT type)
- Use `JsonType::class` for JSON fields (auto-encodes arrays/objects)
- POINT fields accept string `'lat lon'`, array `[lat, lon]`, or object formats
- JSON fields accept arrays or objects (auto-encoded during insert/update)
- Extract coordinates using SQL functions: `[['X(`field`)'], 'latitude']`
- NO custom Storage class needed - base Storage handles everything automatically

### Storage

**Base**: `Proto\Storage\Storage`

**Create ONLY if custom queries needed**. Otherwise use model methods.

**Filter Arrays**:
Storage methods can use filter arrays if set. This is an array that can add a clause to the storage query.

Filter keys in the array can be ambiguous and might need to be prefixed with the table alias if the model is
joining tables using eager joins.
```php
$filter = [
    "id = '1'", // ambiguous
    "a.id = '1'", // raw condition with table alias
    ["a.created_at BETWEEN ? AND ?", ['2021-02-02', '2021-02-28']], // Manual bind
    ['a.id', $user->id], // auto bind
    ['a.id', '>', $user->id] // auto bind with operator
];

$row = User::getBy($filter);   // one
$rows = User::fetchWhere($filter);   // many`
```

**Query Builder Methods**:
- `select()`, `insert()`, `update()`, `delete()`
- `join()`, `leftJoin()`, `rightJoin()`, `outerJoin()`
- `where()`, `in()`, `orderBy()`, `groupBy()`, `having()`, `distinct()`, `limit()`
- `union()` - combine queries

**Query Builder**:
```php
class UserStorage extends Storage
{
    public function getActiveUsers(int $limit = 10): array
    {
        return $this->table()
            ->select()
            ->where('status = ?', 'deleted_at IS NULL')
            ->orderBy('created_at DESC')
            ->limit($limit)
            ->fetch(['active']);
    }

    // Conditional where clauses
    public function getRecords(int $id, ?string $type = null): array
    {
        $sql = $this->table()
            ->select()
            ->where('parent_id = ?', 'deleted_at IS NULL');

        $params = [$id];
        if ($type)
        {
            $sql->where('type = ?');
            $params[] = $type;
        }

        return $sql->fetch($params);
    }

    // Update with builder
    public function updateStatus(int $id, string $status): bool
    {
        return $this->table()
            ->update()
            ->set(['status' => $status, 'updated_at' => 'NOW()'])
            ->where('id = ?')
            ->execute([$id]);
    }
}
```

**Debugging Queries**:
```php
// Print the SQL string
echo $sql;

// Debug with parameters
$sql->debug();
```

**Helper Methods**:
- `table()` - model's query builder
- `builder(table, alias)` - custom table builder
- `select()` - selects default columns
- `where()` - creates filtered queries

**searchByJoin() Method**:
Automatically generates EXISTS subqueries for searching within nested join data:
```php
// OLD WAY - Manual EXISTS subquery
$sql->where("EXISTS (
    SELECT 1 FROM conversation_participants cpp
    INNER JOIN users u ON cpp.user_id = u.id
    WHERE cpp.conversation_id = cp.conversation_id
    AND (u.first_name LIKE ? OR u.last_name LIKE ?)
)");

// NEW WAY - Automatic subquery generation
protected function setCustomWhere($sql, &$params, $options)
{
    if (!empty($options['search']))
    {
        $sql->where(
            $this->searchByJoin('participants', ['firstName', 'lastName'], $options['search'], $params)
        );
    }
}
```

**Ad-hoc Queries** (when custom storage not needed):
```php
// In Model static methods
public static function getActiveUsers(): array
{
    return static::builder()
        ->select()
        ->where('status = ?', 'deleted_at IS NULL')
        ->fetch(['active']);
}

// Using closures (compact syntax)
$users = User::storage()->findAll(
    fn($sql, &$p) => (
        $p[] = 'active',
        $sql->where('status = ?')->orderBy('created_at DESC')
    )
);
```

**CRITICAL**:
- DO NOT specify `$tableName` or `$connection` (unless non-default DB)
- Use builder's `fetch()` directly: `->fetch($params)` NOT `$this->fetch($sql, $params)`
- Chain multiple where conditions in single call
- Use `first()` not `fetchOne()`
- ALWAYS use builder methods, NEVER raw SQL with table names
- NO `getTableName()` method exists - always use builder

### Migrations

**Location**: `common/Migrations` or `modules/*/Migrations`

**CRITICAL Naming Convention**:
Migration files MUST follow this exact pattern:
- **Filename**: `YYYY-MM-DDTHH.MM.SS.MICROSECONDS_ClassName.php`
- **Class Name**: Must match the portion AFTER the underscore in the filename
- **Example**: File `2026-01-21T04.14.30.800125_Event.php` → class name `Event`
- **NOT Laravel Style**: Don't use `CreateEventsTable.php` or `Create_events_table.php`

To generate correct timestamp:
```bash
date +"%Y-%m-%dT%H.%M.%S.%6N"
# Example output: 2026-01-21T04.14.30.800125
```

**Structure**:
```php
<?php declare(strict_types=1);

use Proto\Database\Migrations\Migration;

class CreateUsersTable extends Migration
{
    public function up(): void
    {
        $this->create('users', function($table)
        {
            $table->id();
            $table->uuid();
            $table->varchar('name', 100);
            $table->varchar('email', 255);
            $table->timestamps();
        });

        $this->alter('test_table', function($table)
        {
            // rename table
            $table->rename('new_name');

            $table->engine('InnoDB');

            // add new field
            $table->add('status')->int(20);
            // or
            $table->int('status', 20);

            // modify existing field
            $table->alter('subject')->varchar(180);

            // drop field
            $table->drop('read_at');

            // add index
            $table->index('idx_new_index')->fields('user_id', 'created_at');
            // drop index
            $table->dropIndex('idx_old_index');

            // add foreign key
            $table->foreign('user_id')
                ->references('id')
                ->on('users')
                ->onDelete('CASCADE');

            // drop foreign key
            $table->dropForeignKey('fk_user_id');
        });
    }

    public function down(): void
    {
        $this->drop('users');
    }
}
```

**Field Types**:

**Primary Keys & IDs**:
- `$table->id(length = 30)` - INT primary key with auto increment
- `$table->uuid(length = 36)` - VARCHAR UUID field with unique index

**Integer Types**:
- `$table->tinyInteger(length = 1)` - TINYINT (1 byte, -128 to 127)
- `$table->boolean()` - Alias for tinyInteger, use for true/false values
- `$table->smallInteger(length)` - SMALLINT (2 bytes, -32768 to 32767)
- `$table->mediumInteger(length)` - MEDIUMINT (3 bytes)
- `$table->integer(length)` or `$table->int(length)` - INT (4 bytes)
- `$table->bigInteger(length)` - BIGINT (8 bytes)

**Decimal & Float Types**:
- `$table->decimal(length)` - DECIMAL (exact precision for currency/financial)
- `$table->floatType(length)` - FLOAT (approximate, 4 bytes)
- `$table->doubleType(length)` - DOUBLE (approximate, 8 bytes)

**String Types**:
- `$table->char(length)` - CHAR (fixed-length string)
- `$table->varchar(length)` - VARCHAR (variable-length string, max 65535)

**Text Types**:
- `$table->tinyText()` - TINYTEXT (max 255 chars)
- `$table->text()` - TEXT (max 65,535 chars)
- `$table->mediumText()` - MEDIUMTEXT (max 16MB)
- `$table->longText()` - LONGTEXT (max 4GB)

**Binary Types**:
- `$table->binary(length)` - BINARY (fixed-length binary)
- `$table->bit()` - BIT (default length 1)
- `$table->tinyBlob()` - TINYBLOB (max 255 bytes)
- `$table->blob(length)` - BLOB (max 65KB)
- `$table->mediumBlob(length)` - MEDIUMBLOB (max 16MB)
- `$table->longBlob(length)` - LONGBLOB (max 4GB)

**Date & Time Types**:
- `$table->date()` - DATE (YYYY-MM-DD)
- `$table->datetime()` - DATETIME (YYYY-MM-DD HH:MM:SS)
- `$table->timestamp()` - TIMESTAMP (auto-updates on change)

**Special Types**:
- `$table->enum('field', 'val1', 'val2', 'val3')` - ENUM (predefined values list)
- `$table->json()` - JSON (native JSON column type)
- `$table->point()` - POINT (spatial data for geo coordinates)

**Field Modifiers**:
- `->nullable()` - Allow NULL values
- `->default(value)` - Set default value
- `->currentTimestamp()` - Default to CURRENT_TIMESTAMP
- `->utcTimestamp()` - Default to UTC_TIMESTAMP
- `->primary()` - Set as primary key
- `->autoIncrement()` - Enable auto increment
- `->after('field')` - Position after specified field
- `->rename('newName')` - Rename field

**Audit Fields**:
- `$table->timestamps();` - created_at, updated_at
- `$table->createdAt();` - created_at only
- `$table->updatedAt();` - updated_at only
- `$table->deletedAt();` - soft delete

**Indexes**:
- Single: `$table->index('idx_name')->fields('field');`
- Multiple: `$table->index('idx_name')->fields('field1', 'field2');`
- Unique: `$table->unique('unq_name')->fields('field1');`

**Foreign Keys**:
```php
$table->foreign('user_id')
    ->references('id')
    ->on('users')
    ->onDelete('CASCADE');
```

**Complete Migration Example**:
```php
<?php declare(strict_types=1);

use Proto\Database\Migrations\Migration;

class CarMaintenanceRecord extends Migration
{
    public function up(): void
    {
        $this->create('car_maintenance_records', function($table)
        {
            // Primary key
            $table->id();
            $table->uuid();

            // Foreign keys
            $table->integer('car_profile_id', 30);
            $table->integer('user_id', 30);

            // Fields
            $table->varchar('title', 200);
            $table->text('description')->nullable();
            $table->enum('type', 'routine', 'repair', 'inspection')->default("'routine'");
            $table->date('service_date');
            $table->decimal('cost', 10, 2)->nullable();

            // Audit fields
            $table->createdAt();
            $table->integer('created_by', 30)->nullable();
            $table->updatedAt();
            $table->integer('updated_by', 30)->nullable();
            $table->deletedAt();

            // Indexes
            $table->index('car_profile_idx')->fields('car_profile_id', 'service_date');
            $table->index('user_idx')->fields('user_id');

            // Foreign keys
            $table->foreign('car_profile_id')->references('id')->on('car_profiles')->onDelete('CASCADE');
            $table->foreign('user_id')->references('id')->on('users')->onDelete('CASCADE');
        });
    }

    public function down(): void
    {
        $this->drop('car_maintenance_records');
    }
}
```

**CRITICAL**:
- Extend `Proto\Database\Migrations\Migration`
- Use `up()` and `down()` NOT `run()` and `revert()`
- Use `foreign()` NOT `foreignKey()` or `foreignId()`
- DO NOT specify `$connection` unless non-default DB

### Services

**Base**: `Common\Services\Service`

**Pattern**: Services coordinate business logic, models handle data access.

**Single Responsibility Principle**:
- Methods should do ONE thing well
- Break complex methods into smaller, focused helper methods
- Each method should have a clear, single purpose
- Avoid methods that mix validation, business logic, and persistence

**Succinct Model Instantiation**:
Always use constructor with object for efficiency:

```php
// ✅ CORRECT - Succinct
$member = new GroupMember((object)[
    'groupId' => $groupId,
    'userId' => $userId,
    'role' => $role
]);
$member->add();

// ✅ CORRECT - With conditional data
$memberData = [
    'groupId' => $groupId,
    'userId' => $userId,
    'role' => $role
];
if ($invitedBy)
{
    $memberData['invitedBy'] = $invitedBy;
}
$member = new GroupMember((object)$memberData);
$member->add();

// ❌ WRONG - Verbose
$member = new GroupMember();
$member->groupId = $groupId;
$member->userId = $userId;
$member->role = $role;
$member->add();
```

**Refactoring Long Methods**:
```php
// ❌ WRONG - Method doing too much
public function createGroup(int $userId, array $data): object|false
{
    // Validation
    $existing = Group::getBy(['slug' => $data['slug']]);
    if ($existing) return false;

    // Stripe setup
    if (!empty($data['requiresFee']))
    {
        $stripeProduct = $this->createStripeProduct(...);
        $stripePrice = $this->createStripePrice(...);
        $data['stripeProductId'] = $stripeProduct->id;
    }

    // Create group
    $group = new Group((object)$data);
    $group->add();

    // Add member
    $this->addGroupMember($group->id, $userId);

    // Update counts
    $community = Community::get($communityId);
    $community->groupCount++;
    $community->update();

    return $group;
}

// ✅ CORRECT - Delegated to focused methods
public function createGroup(int $userId, int $communityId, array $data): object|false
{
    if (!$this->isGroupSlugUnique($communityId, $data['slug']))
    {
        return false;
    }

    $stripeData = $this->setupGroupStripeIntegration($data);
    if ($stripeData === false)
    {
        return false;
    }

    $group = $this->createGroupRecord($userId, $communityId, array_merge($data, $stripeData));
    if (!$group)
    {
        return false;
    }

    $this->addGroupMember($group->id, $userId, 'owner', null);
    $this->incrementCommunityGroupCount($communityId);

    return Group::get($group->id);
}

protected function isGroupSlugUnique(int $communityId, string $slug): bool
{
    $existing = Group::getBy(['communityId' => $communityId, 'slug' => $slug]);
    return $existing === null;
}

protected function setupGroupStripeIntegration(array $data): array|false
{
    if (empty($data['requiresFee'])) return [];
    // ... focused Stripe setup logic
}

protected function createGroupRecord(int $userId, int $communityId, array $data): ?Group
{
    $group = new Group((object)array_merge($data, [
        'communityId' => $communityId,
        'createdBy' => $userId,
        'memberCount' => 1
    ]));
    $group->add();
    return $group->id ? $group : null;
}

protected function incrementCommunityGroupCount(int $communityId): void
{
    $community = Community::get($communityId);
    if ($community)
    {
        $community->groupCount++;
        $community->update();
    }
}
```

**CRITICAL**:
- Services NEVER instantiate storage classes directly
- ❌ WRONG: `$storage = new UserStorage(); $storage->getUsers();`
- ✅ CORRECT: `User::fetchWhere([...])`
- For complex queries, add static methods to model that delegate to storage
- Extract repeated logic into focused helper methods
- Helper methods should be protected unless needed elsewhere

### Validation

**Format**: `'type[:max]|required'`

**Types**: `int`, `float`, `string`, `email`, `ip`, `phone`, `mac`, `bool`, `url`, `domain`

**Image Validation**:
```php
// In validation rules
'image' => 'image:1024|required|mimes:jpeg,png'

// Direct validation
use Proto\Utils\Validation\ImageValidator;
$result = ImageValidator::validate($uploadFile, $maxSizeKB, $mimeTypes);
```

**Supported image MIME types**: jpeg, jpg, png, gif, webp, bmp, tiff

**Examples**:
- `'string:255|required'`
- `'email|required'`
- `'int|required'`

### Auth & Policies

**Gates** (Authentication helpers):
```php
// Create in Common/Auth extending Proto\Auth\Gates\Gate
class UserGate extends Gate
{
    public function isUser(int $userId): bool
    {
        $sessionUserId = $this->session->get('user')->id ?? null;
        return $sessionUserId === $userId;
    }

    public function isAdmin(): bool
    {
        return $this->session->get('role') === 'admin';
    }
}

// Register globally
$auth = auth();
$auth->user = new UserGate();
$auth->user->isUser(1); // Use anywhere
```

**Policies** (Authorization):
The Common policy adds a type proprety to identify the policy type and uses a request method to
check if the user is authorized to perform the action by the typer and request action method.

Module policies extend the Common policy and define per-action methods as needed.

```php
use Proto\Http\Router\Request;
// Create in Modules/ModuleName/Auth/Policies extending Common\Auth\Policies\Policy
class UserPolicy extends Policy
{
    /**
     * The type of the policy.
     *
     * @var string|null
     */
    protected ?string $type = 'user';

    // Runs before all methods
    // override to add a before check that applies to all actions
    public function before(Request $request): bool
    {
        return (auth()->user->isAdmin());

        // or to check if they use ris signed in
        // return $this->isSignedIn();
    }

    // override this to add a default policy for all actions if no per-action method exists
    public function default(Request $request): bool
    {
        return false;
    }

    // Per-action methods
    public function get(Request $request): bool
    {
        $id = $this->getResourceId($request);
        return auth()->user->isUser($id);
    }

    // after method hook example
    public function afterGet(mixed $result): bool
    {
        // check the result object if needed
        $userId = session()->user->id ?? null;
        if (!$userId)
        {
            return false;
        }

        return ($result->id === $userId);
    }

    public function update(Request $request): bool
    {
        $id = $this->getResourceId($request);
        return auth()->user->isUser($id);
    }
}

// Apply to controller
class UserController extends ResourceController
{
    protected ?string $policy = UserPolicy::class;
}

// Routes with dynamic params
router()->resource('user/:userId/account', UserController::class);
```

## 4. Frontend Development (Base Framework)

### Core Philosophy

**CRITICAL: This is NOT React/Vue/JSX**

- **No Templates**: Structure defined via plain JavaScript objects
- **No JSX**: Parser turns objects into DOM
- **Children as 2nd argument**: NEVER in props
- **Reactive Data**: Use `new Data({})` NOT `useState`
- **Component instances**: Always `new Component()`, never `new Atom()`

### Code Style (CRITICAL)

#### Braces
**Opening braces ALWAYS on new line** (methods, classes, if/else, loops):
```javascript
// ✅ CORRECT
export class HomePage extends Component
{
    render()
    {
        return Div({ class: 'page' }, [
            Header()
        ]);
    }

    afterSetup()
    {
        if (this.data.loaded)
        {
            this.loadData();
        }
    }
}

// Atoms can have inline return
export const QuickAction = Atom(({ icon, label, click }) => (
    Button({
        class: 'flex h-10 items-center gap-2',
        click
    }, [
        UniversalIcon({ size: 'sm' }, icon)
    ])
));

// ❌ WRONG - Opening brace on same line
export class HomePage extends Component {
    render() {
        return Div({ class: 'page' }, [
            Header()
        ]);
    }
}
```

#### Semicolons
**ALWAYS use semicolons**:
```javascript
// ✅ CORRECT
const data = new Data({ count: 0 });
this.data.count = 5;
app.navigate('home');

// ❌ WRONG
const data = new Data({ count: 0 })
this.data.count = 5
app.navigate('home')
```

#### Theme Colors (CRITICAL)
**ALWAYS use theme variables, NEVER hardcoded colors**:
```javascript
// ✅ CORRECT - Theme variables
{ class: 'text-foreground bg-surface border-border' }
{ class: 'text-primary hover:text-primary-hover' }
{ class: 'bg-accent text-accent-foreground' }
{ class: 'bg-gradient-to-r from-primary to-accent' }

// ❌ WRONG - Hardcoded colors
{ class: 'text-white bg-black border-gray-300' }
{ class: 'text-blue-500 hover:text-blue-700' }
{ class: 'bg-red-500 text-white' }
```

**Available Theme Variables**:
- **Text**: `text-foreground`, `text-muted-foreground`, `text-primary`, `text-accent`, `text-destructive`
- **Background**: `bg-background`, `bg-surface`, `bg-surface-dark`, `bg-muted`, `bg-primary`, `bg-accent`, `bg-destructive`
- **Border**: `border-border`, `border-input`, `border-primary`, `border-accent`
- **Foreground**: `text-primary-foreground`, `text-accent-foreground`, `text-destructive-foreground`
- **Hover States**: `hover:bg-muted`, `hover:text-primary`, `hover:border-primary`

### File Organization
Files should be organized by feature/module. Each module contains its own components, models, and pages. Shared components can be placed in a common directory if needed. Folders should be structures in nested levels of organisms, molecules, and atoms to reflect component complexity and reusability. Nested folders can be created for specific atoms, molecules, or organisms if needed for organization.

e.g.
```
atoms/
    /cards
        post-card.js
        user-card.js
    /buttons
        primary-button.js
```

**Module Structure**:
```
apps/{crm,main}/src/modules/
  {moduleName}/
    module.js                    # Module registration
    components/
      models/                    # API models
        {name}-model.js
      pages/                     # Full page components
        {pageName}/
          {pageName}-page.js
          organisms/             # Complex composite components
            {name}.js
          molecules/             # Mid-level components
            {name}.js
          atoms/                 # Simple reusable components
            {name}.js
      organisms/                 # Shared organisms across module
      molecules/                 # Shared molecules across module
      atoms/                     # Shared atoms across module
```

**Example Structure**:
```
apps/main/src/modules/
  home/
    module.js
    components/
      models/
        feed-model.js
      pages/
        home/
          home-page.js           # Main page component
          organisms/
            feed-section.js
            assistant-panel.js
          molecules/
            post-card.js
            quick-actions-bar.js
          atoms/
            post-header.js
            action-button.js
```

### Common Mistakes (READ FIRST)

1. ❌ DON'T use templates or JSX
2. ❌ DON'T pass children in props: `Div({ children: [...] })`
3. ❌ DON'T use `new` with Atoms: `new Button()`
4. ❌ DON'T forget `new` with Components: `MyComponent()`
5. ❌ DON'T use `.map()` for reactive lists - use `map` or `for` directive
6. ❌ DON'T use `Import('./file.js')` - use function form
7. ❌ DON'T call `render()` directly
8. ❌ DON'T access DOM before `afterSetup()`
9. ❌ DON'T use hardcoded colors - use theme variables
10. ❌ DON'T put opening braces on same line (except inline Atom returns)

### Modules System

**Location**: `apps/{crm,main}/src/modules/{moduleName}/module.js`

**Purpose**: Define routes, navigation links, and register module with the app.

**Structure**:
```javascript
import { Icons } from "@base-framework/ui/icons";
import { Module } from '../module/module.js';

/**
 * Routes for the module
 * @type {Array<object>}
 */
const routes = Module.convertRoutes(
[
    {
        path: '/',
        import: () => import('./components/pages/home/home-page.js'),
        title: 'Home'
    },
    {
        path: '/settings',
        import: () => import('./components/pages/settings/settings-page.js'),
        title: 'Settings'
    }
]);

/**
 * Navigation links for the module
 * @type {Array<object>}
 */
const links =
[
    {
        label: 'Home',
        href: './',
        icon: Icons.home,
        mobileOrder: 1,
        exact: true
    },
    {
        label: 'Settings',
        href: './settings',
        icon: Icons.settings,
        mobileOrder: 5
    }
];

/**
 * Create and register the module
 */
Module.create(
{
    routes,
    links
});
```

**Route Options**:
- `path` (string): Route path (relative to module base)
- `import` (function): Dynamic import function
- `title` (string): Page title
- `exact` (boolean): Exact path match only

**Link Options**:
- `label` (string): Display text
- `href` (string): Navigation path (relative: `./`, `./page`)
- `icon` (string|object): Icon from `Icons` (Heroicons SVG), `MaterialSymbols`, or a Material Symbol name string
- `mobileOrder` (number): Order in mobile nav (1-10)
- `exact` (boolean): Highlight only on exact match

**Registration**:
Add module to `apps/{crm,main}/src/modules/imported-modules.js`:
```javascript
/**
 * Import all modules in order
 */
import "./activity/module.js";
import "./community/module.js";
import "./home/module.js";
import "./settings/module.js";  // New module
```

### Component Structure

**Page Component**:
```javascript
import { Component, Data } from '@base-framework/base';
import { Div, Button } from '@base-framework/atoms';
import { BlankPage } from '@base-framework/ui/pages';
import { FeedModel } from '../../models/feed-model.js';
import { FeedSection } from './organisms/feed-section.js';

/**
 * HomePage
 *
 * Main home page combining feed and assistant
 *
 * @returns {BlankPage}
 */
export class HomePage extends Component
{
    /**
     * Set up reactive data
     *
     * @returns {Data}
     */
    setData()
    {
        return new FeedModel({
            posts: [],
            loading: true,
            filter: {}
        });
    }

    /**
     * Set up local state
     *
     * @returns {object}
     */
    setupStates()
    {
        return {
            isOpen: false,
            view: 'grid'
        };
    }

    /**
     * Render the page
     *
     * @returns {object}
     */
    render()
    {
        return BlankPage({ class: 'home-page' }, [
            FeedSection(this.data)
        ]);
    }

    /**
     * After DOM is created
     */
    afterSetup()
    {
        this.loadFeed();
    }

    /**
     * Load feed data from API
     */
    loadFeed()
    {
        this.data.xhr.all({}, (response) =>
        {
            if (response.success)
            {
                this.data.set('posts', response.data);
                this.data.set('loading', false);
            }
        });
    }

    /**
     * Cleanup before destroy
     */
    beforeDestroy()
    {
        // Clean up subscriptions, timers, etc.
    }
}

export default HomePage;
```

**Organism Component**:
```javascript
import { Div, H2 } from '@base-framework/atoms';
import { Atom } from '@base-framework/base';
import { PostCard } from '../molecules/post-card.js';

/**
 * FeedSection
 *
 * Main feed section displaying posts
 *
 * @param {Data} data - Feed data
 * @returns {object}
 */
export const FeedSection = Atom((data) => (
    Div({ class: 'feed-section w-full' }, [
        H2({ class: 'text-2xl font-bold text-foreground mb-4' }, 'Feed'),
        Div({
            class: 'space-y-4',
            for: [data, 'posts', (post) => PostCard(post)]
        })
    ])
));

export default FeedSection;
```

**Molecule Component**:
Molecules are reusable layouts that combine atoms and can be used across different organisms or pages. Large molecules that are specific to a single organism can be placed in an `organisms` subfolder instead.

Molecules and organisms should factor out the major portions to smaller atoms, molecules, and organisms to keep the layout maintainable and reusable.
```javascript
import { Avatar, Card, Button } from '@base-framework/ui/atoms';
import { Div, Img, P, Span } from '@base-framework/atoms';
import { Atom } from '@base-framework/base';
import { UniversalIcon } from '@base-framework/ui/atoms';
import { Icons, MaterialSymbols } from '@base-framework/ui/icons';

/**
 * UserName
 *
 * Simple molecule for displaying user name and time
 *
 * @param {object} post - Post data
 * @returns {object}
 */
const UserName = (post) => (
    Div({ class: 'flex-1' }, [
        P({ class: 'font-semibold text-foreground' }, post.user.name),
        P({ class: 'text-sm text-muted-foreground' }, post.timeAgo)
    ])
);

/**
 * UserHeader
 *
 * Header section of a post card showing user info and options
 *
 * @param {object} post - Post data
 * @returns {object}
 */
const UserHeader = (post) => (
    Div({ class: 'flex items-center gap-3 p-4' }, [
        Avatar({
            src: post.user.avatar,
            alt: post.user.name,
            fallback: post.user.name[0]
        }),
        UserName(post),
        Button({
            variant: 'ghost',
            size: 'icon',
            click: () => handleOptions(post)
        }, [
            UniversalIcon({ size: 'sm' }, MaterialSymbols.more_vert)
        ])
    ])
);

/**
 * PostImage
 *
 * Image section of a post card
 *
 * @param {string} src - Image URL
 * @returns {object}
 */
const PostImage = (src) => (
    Img({
        src,
        class: 'w-full aspect-video object-cover'
    })
);

/**
 * Content
 *
 * Text content section of a post card
 *
 * @param {string} text - Post content
 * @returns {object}
 */
const Content = (text) => (
    Div({ class: 'p-4' }, [
        P({ class: 'text-foreground' }, text)
    ])
);

/**
 * ButtonGroup
 *
 * Action buttons for a post card (like, comment)
 *
 * @param {number} likes - Like count
 * @param {number} comments - Comment count
 * @param {function} onLike - Like button handler
 * @param {function} onComment - Comment button handler
 * @returns {object}
 */
const ButtonGroup = ({ likes, comments, onLike, onComment }) => (
    Div({ class: 'flex items-center gap-6 px-4 pb-4 text-muted-foreground' }, [
        Button({
            variant: 'withIcon',
            class: 'flex items-center gap-2',
            click: onLike,
            icon: Icons.hand.thumb.up
        }, String(likes)),
        Button({
            variant: 'withIcon',
            class: 'flex items-center gap-2',
            click: onComment,
            icon: Icons.chat
        }, String(comments))
    ])
);

/**
 * PostCard
 *
 * Individual post card in feed
 *
 * @param {object} post - Post data
 * @returns {object}
 */
export const PostCard = Atom((post) => (
    Card({ class: 'post-card' }, [

        UserHeader(post),
        post.image && PostImage(post.image),

        Content(post.content),

        ButtonGroup({
            likes: post.likes,
            comments: post.comments,
            onLike: () => {},
            onComment: () => {}
        })
    ])
));

export default PostCard;
```

**Atom Component**:
```javascript
import { Button, Span } from '@base-framework/atoms';
import { Atom } from '@base-framework/base';
import { UniversalIcon } from '@base-framework/ui/atoms';

/**
 * QuickAction
 *
 * A single quick action button
 *
 * @param {object} props
 * @returns {object}
 */
export const QuickAction = Atom(({ icon, label, click }) => (
    Button({
        class: 'flex h-10 items-center gap-2 rounded-lg bg-foreground/5 border border-border pl-3 pr-4 active:scale-95 transition-transform hover:bg-muted shrink-0',
        click
    }, [
        UniversalIcon({ size: 'sm', class: 'text-foreground' }, icon),
        Span({ class: 'text-sm font-bold text-foreground whitespace-nowrap' }, label)
    ])
));

export default QuickAction;
```

### Base UI Components & Icons

**CRITICAL**: Use Base UI components as much as possible before creating custom ones.

**Available Base UI Components**:
```javascript
import {
    Avatar,
    Badge,
    Button,
    Card,
    Checkbox,
    Dialog,
    Input,
    Label,
    Select,
    Switch,
    Tabs,
    Textarea
} from '@base-framework/ui/atoms';
```

### Universal Icon System

Base UI features a **universal icon handler** that seamlessly supports both **Heroicons (SVG-based)** and **Material Symbols (font-based)**. All components automatically detect and render the appropriate icon type.

**Icon Imports**:
```javascript
// Icon components
import { Icon, MaterialIcon, UniversalIcon, isMaterialIcon, isHeroicon } from '@base-framework/ui/atoms';

// Icon libraries
import { Icons, MaterialSymbols } from '@base-framework/ui/icons';
```

**UniversalIcon (Recommended)**:
Use `UniversalIcon` when you want to support both icon systems. All Base UI components (Button, Alert, Modal, Navigation, etc.) use this internally.

```javascript
import { UniversalIcon } from '@base-framework/ui/atoms';
import { Icons, MaterialSymbols } from '@base-framework/ui/icons';

// All of these work with UniversalIcon:
UniversalIcon({ size: 'md' }, Icons.home);                            // Heroicon SVG
UniversalIcon({ size: 'md' }, MaterialSymbols.home);                   // Material Symbol
UniversalIcon({ size: 'md' }, 'home');                                 // Material Symbol name string
UniversalIcon({ size: 'md' }, { name: 'favorite', variant: 'filled' }); // With variant
```

**Icon Detection Logic**:
1. **SVG String** (Heroicons): Contains `<svg` → renders `Icon`
2. **Object with `name`**: Has `.name` property → renders `MaterialIcon` with variant
3. **Plain String**: No `<svg` → treats as Material Symbol name → renders `MaterialIcon`

**Direct Icon Components**:
```javascript
// Heroicons (SVG) - use Icon component directly
import { Icon } from '@base-framework/ui/atoms';
import { Icons } from '@base-framework/ui/icons';

Icon({ size: 'sm' }, Icons.home);
Icon({ size: 'md' }, Icons.settings);

// Material Symbols (Font) - use MaterialIcon component directly
import { MaterialIcon } from '@base-framework/ui/atoms';
import { MaterialSymbols } from '@base-framework/ui/icons';

MaterialIcon({ name: MaterialSymbols.home, size: 'md' });
MaterialIcon({ name: 'notifications', size: 'md' });
MaterialIcon({ name: 'favorite', variant: 'filled', size: 'sm' });
```

**Material Symbol Variants**: `outlined` (default), `filled`, `rounded`, `sharp`

**Consistent Sizes** (both systems use identical pixel sizes):
| Size | Pixels | Tailwind |
|------|--------|----------|
| xs | 16px | w-4 h-4 |
| sm | 24px | w-6 h-6 (default) |
| md | 32px | w-8 h-8 |
| lg | 40px | w-10 h-10 |
| xl | 48px | w-12 h-12 |
| 2xl | 56px | w-14 h-14 |
| 3xl | 64px | w-16 h-16 |

**Using Icons in Components**:
All Base UI components that accept an `icon` prop support both icon systems automatically:
```javascript
import { Button } from '@base-framework/ui/atoms';
import { Icons, MaterialSymbols } from '@base-framework/ui/icons';

// All work automatically - no configuration needed:
Button({ variant: 'withIcon', icon: Icons.plus }, 'Add Item');          // Heroicon
Button({ variant: 'withIcon', icon: MaterialSymbols.add }, 'Add Item');  // Material Symbol
Button({ variant: 'withIcon', icon: 'add' }, 'Add Item');               // Material Symbol name
Button({ variant: 'withIcon', icon: { name: 'favorite', variant: 'filled' } }, 'Like'); // With variant

// Works the same in Alert, Modal, Navigation, etc.
Alert({ type: 'success', icon: Icons.check, title: 'Done!' });
Alert({ type: 'success', icon: MaterialSymbols.status.success, title: 'Done!' });
```

**Helper Functions** (for custom components):
```javascript
import { isMaterialIcon, isHeroicon } from '@base-framework/ui/atoms';

isMaterialIcon('home');              // true
isMaterialIcon(MaterialSymbols.add); // true
isMaterialIcon(Icons.home);          // false (SVG string)

isHeroicon(Icons.home);              // true
isHeroicon('home');                  // false
```

**Custom Components with Universal Icons**:
```javascript
import { Div, Span } from '@base-framework/atoms';
import { Atom } from '@base-framework/base';
import { UniversalIcon } from '@base-framework/ui/atoms';

export const CustomCard = Atom((props) => (
    Div({ class: 'card' }, [
        props.icon && UniversalIcon({ size: 'md' }, props.icon),
        Div({ class: 'card-content' }, props.children)
    ])
));

// Now works with both icon systems:
CustomCard({ icon: Icons.star }, [...]);
CustomCard({ icon: MaterialSymbols.star }, [...]);
CustomCard({ icon: 'star' }, [...]);
```

**Button Variants**:
```javascript
import { Button } from '@base-framework/ui/atoms';

// Use Base UI Button variants
Button({ variant: 'default' }, 'Default');
Button({ variant: 'secondary' }, 'Secondary');
Button({ variant: 'outline' }, 'Outline');
Button({ variant: 'ghost' }, 'Ghost');
Button({ variant: 'link' }, 'Link');
Button({ variant: 'destructive' }, 'Delete');
Button({ variant: 'icon' }, [Icon({ size: 'sm' }, Icons.settings)]);
Button({ variant: 'withIcon', icon: Icons.plus }, 'Add New');
```

**Card Variants**:
```javascript
// Use Base UI Card
Card({ class: 'p-4' }, [
    Div({ class: 'card-header' }, [
        H3({ class: 'text-lg font-semibold text-foreground' }, 'Title')
    ]),
    Div({ class: 'card-content' }, [
        P({ class: 'text-muted-foreground' }, 'Content')
    ])
]);
```

### Layout Patterns

**Basic**:
```javascript
// Props 1st, children 2nd
Div({ class: 'container' }, [
    Div('Text'),
    Button({ click: handler }, 'Click')
]);

// Text only
Div('Just text');

// Props only
Div({ class: 'empty' });
```

**Data Binding**:
```javascript
// Simple watcher
{ class: 'status-[[status]]' }

// Input binding
Input({ bind: 'username' })
Input({ bind: 'user.email' })

// Checkbox
Input({ type: 'checkbox', bind: 'accepted' })

// Select
Select({ bind: 'form.color' }, [
    Option({ value: 'red' }, 'Red'),
    Option({ value: 'blue' }, 'Blue')
])
```

**Lists** (CRITICAL):
```javascript
// ✅ CORRECT - Use for directive (reactive)
Div({ for: ['posts', (post) => PostCard(post)] })

// ✅ CORRECT - Use map directive (static)
Div({ map: [this.data.posts, (post) => PostCard(post)] })

// ✅ Also works for simple cases
Ul([items.map(item => Li(item))])

// ❌ WRONG
Div({ children: items.map(item => ItemCard(item)) })
```

**Watchers & Computed**:
```javascript
// Simple property watch (watches this.data.status)
{ class: 'status-[[status]]' }

// Multiple properties
{ text: 'User: [[name]] Age: [[age]]' }

// Deep paths
{ text: '[[user.profile.name]]' }

// Multi-data watcher
{ class: ['[[propName]] [[otherPropName]]', [data1, data2]] }
```

**Conditionals**:
```javascript
// Simple conditional
{ children: [condition && element] }

// Conditional with alternative
{
    children: [
        condition ? TrueComponent() : FalseComponent()
    ]
}

// Multiple conditions
{
    children: [
        loading && LoadingSpinner(),
        !loading && data.items.length > 0 && ItemsList(),
        !loading && data.items.length === 0 && EmptyState()
    ]
}
```

### Models (API Integration)

**Location**: `apps/{crm,main}/src/modules/{moduleName}/components/models/{name}-model.js`

**Purpose**: Handle API communication and data management.

**Structure**:
```javascript
import { Model } from "@base-framework/base";

/**
 * FeedModel
 *
 * Handles feed API operations
 *
 * @type {typeof Model}
 */
export const FeedModel = Model.extend({
    /**
     * Base API URL
     */
    url: '/api/feed',

    /**
     * Custom API methods
     */
    xhr: {
        /**
         * Get all posts with filters
         *
         * @param {object} instanceParams
         * @param {function} callBack
         * @returns {XMLHttpRequest}
         */
        all(instanceParams, callBack)
        {
            const data = this.model.get();
            const params = {
                filter: data.filter || {},
                limit: data.limit || 20,
                offset: data.offset || 0
            };

            return this._get('', params, instanceParams, callBack);
        },

        /**
         * Add a new post
         *
         * @param {object} instanceParams
         * @param {function} callBack
         * @param {FileList|File[]} [files] - Optional file attachments
         * @returns {XMLHttpRequest}
         */
        add(instanceParams, callBack, files)
        {
            const data = this.model.get();

            // Without files - send JSON
            if (!files || files.length === 0)
            {
                const params = this.setupObjectData(data);
                return this._post('', params, instanceParams, callBack);
            }

            // With files - use FormData
            const formData = new FormData();
            Object.keys(data).forEach(key =>
            {
                if (key !== 'attachments')
                {
                    formData.append(key, data[key]);
                }
            });

            Array.from(files).forEach(file =>
            {
                formData.append('attachments[]', file);
            });

            return this._post('', formData, instanceParams, callBack);
        },

        /**
         * Update existing post
         *
         * @param {object} instanceParams
         * @param {function} callBack
         * @returns {XMLHttpRequest}
         */
        update(instanceParams, callBack)
        {
            const params = this.setupObjectData();
            const id = this.model.id;
            const url = id ? `/${id}` : '';

            return this._patch(url, params, instanceParams, callBack);
        },

        /**
         * Delete post
         *
         * @param {object} instanceParams
         * @param {function} callBack
         * @returns {XMLHttpRequest}
         */
        delete(instanceParams, callBack)
        {
            const id = this.model.id;
            if (!id) return false;

            return this._delete(`/${id}`, {}, instanceParams, callBack);
        },

        /**
         * Real-time sync using Server-Sent Events
         *
         * @param {object} instanceParams
         * @param {function} callBack
         * @param {function} onOpenCallBack
         * @returns {object} { source, cleanup }
         */
        sync(instanceParams, callBack, onOpenCallBack)
        {
            const lastId = instanceParams?.lastId || 0;
            const params = lastId ? `lastId=${lastId}` : '';
            return this.setupEventSource('/sync', params, callBack, onOpenCallBack);
        }
    }
});
```

**Usage in Component**:
```javascript
import { Component } from '@base-framework/base';
import { FeedModel } from '../../models/feed-model.js';

export class FeedPage extends Component
{
    setData()
    {
        return new FeedModel({
            posts: [],
            loading: true,
            filter: { type: 'all' }
        });
    }

    afterSetup()
    {
        // Load initial data
        this.data.xhr.all({}, (response) =>
        {
            if (response.success)
            {
                this.data.set('posts', response.data);
                this.data.set('loading', false);
            }
        });

        // Set up real-time sync
        this.data.xhr.sync(
            { lastId: 0 },
            (updates) =>
            {
                // Handle real-time updates
                if (updates.merge)
                {
                    updates.merge.forEach(post =>
                    {
                        this.data.push('posts', post);
                    });
                }
            },
            () =>
            {
                console.log('Sync connected');
            }
        );
    }

    beforeDestroy()
    {

    }
}
```

### State Management

**Component Data**:
```javascript
setData()
{
    return new Data({
        count: 0,
        items: [],
        user: { name: '' }
    });
}

// Update
this.data.count = 5;
this.data.set('count', 5);
this.data.push('items', item);
this.data.refresh('key');
```

**Component States**:
```javascript
setupStates()
{
    return {
        isOpen: false,
        view: 'list'
    };
}

// Update
this.state.set('isOpen', true);
this.state.toggle('isOpen');
this.state.increment('count');
```

### HTTP Requests

```javascript
import { Ajax } from '@base-framework/base';

// GET
Ajax({
    method: 'GET',
    url: '/api/users',
    params: { active: 1 },
    completed: (response, xhr) =>
    {
        if (response.success)
        {
            // Handle response
        }
    }
});

// POST
Ajax({
    method: 'POST',
    url: '/api/users',
    params: { name: 'John', email: 'john@example.com' },
    completed: (response) =>
    {
        if (response.success)
        {
            app.notify({
                type: 'success',
                title: 'Success',
                description: 'User created'
            });
        }
    }
});
```

### Routing

```javascript
import { router, NavLink } from '@base-framework/base';

// Setup FIRST (in main.js)
router.setup('/app/', 'App Title');

// Navigate programmatically
app.navigate('home');
app.navigate('user/profile');
router.navigate('/settings');

// Switch (first match)
{
    switch: [
        { uri: '/login', component: Login },
        { uri: '/users/:id', component: UserDetail },
        { component: NotFound }
    ]
}

// Access params in component
class UserDetail extends Component
{
    render()
    {
        const id = this.route.id;
        return Div(`User ID: ${id}`);
    }
}

// NavLink
new NavLink({
    href: '/users',
    text: 'Users',
    exact: true,
    activeClass: 'active'
});
```

### Dynamic Imports

```javascript
import { Import } from '@base-framework/base';

// ✅ CORRECT - Function form (required for Vite)
Import(() => import('./components/heavy.js'))

// In module routes
const routes = Module.convertRoutes(
[
    {
        path: '/dashboard',
        import: () => import('./components/pages/dashboard/dashboard-page.js'),
        title: 'Dashboard'
    }
]);

// Conditional import in component
{
    children: [
        condition && Import(() => import('./components/heavy-component.js'))
    ]
}

// ❌ WRONG - String path doesn't work with Vite
Import('./file.js')
```

### Common Patterns

**Loading States**:
```javascript
setData()
{
    return new Data({
        title: 'My Page',
        activeClass: 'inactive',
        items: [],
        loading: true
    });
}

render()
{
    // Dynamic class with watcher for active state in class string
    return Div({ class: 'page', class: 'is-[[activeClass]]' }, [

        // Dynamic text with watcher for data title
        H1('[[title]]'),

        // reactive when using bindable data sources
        If('loading', true, () => LoadingSpinner()),
        If('loading', false, () => ContentSection(this.data)),

        // On uses the Data, or context Data, or state in that order of priority
        On('loading', (loading) =>
        {
            return (loading)
            ? LoadingSpinner()
            : ContentSection(this.data);
        }),

        // Base atoms includes many smart atoms
        // On, OnState, If, IfState, OnRoute, UseParent, OnLoad, OnStateLoad, OnOpen, OnStateOpen
    ]);
}
```

**Empty States**:
```javascript
render()
{
    const something = false;
    return Div({ class: 'page' }, [

        // static conditional rendering that does not react to changes in data
        this.data.items.length > 0 && ItemsList(this.data.items),
        this.data.items.length === 0 && EmptyState({
            message: 'No items found',
            icon: Icons.inbox
        })

        something && EmptyState() // Simple static conditional rendering
    ]);
}
```

**Error Handling**:
```javascript
afterSetup()
{
    this.data.xhr.all({}, (response, xhr) =>
    {
        if (response.success)
        {
            this.data.set('items', response.data);
        }
        else
        {
            app.notify({
                type: 'destructive',
                title: 'Error',
                description: response.message || 'Failed to load data',
                icon: Icons.warning
            });
        }
    });
}
```

**Form Submission**:
```javascript

setData()
{
    return new Data({
        form: {
            name: '',
            email: ''
        }
    });
}

render()
{
    return Form({ submit: (e) => this.handleSubmit(e) }, [
        Input({ bind: 'form.name', placeholder: 'Name' }),
        Input({ bind: 'form.email', placeholder: 'Email' }),
        Button({ type: 'submit' }, 'Submit')
    ]);
}

handleSubmit(e)
{
    e.preventDefault();

    const formData = this.data.get('form');

    this.data.xhr.add({}, (response) =>
    {
        if (response.success)
        {
            app.notify({
                type: 'success',
                title: 'Success',
                description: 'Form submitted'
            });
            app.navigate('list');
        }
    });
}

## 5. Anti-Patterns (What NOT to Do)

### Backend (PHP)

| ❌ WRONG | ✅ CORRECT |
|---------|-----------|
| `User::delete(1)` | `User::remove(1)` or `$user->delete()` |
| `new UserStorage()` in Controller | `User::fetchWhere([...])` |
| `$table->foreignKey('user_id')` | `$table->foreign('user_id')` |
| `function test() {` | `function test()\n{` |
| `$user = User::create($data);` | `$user = new User(); $user->add();` |
| `->where('a')->where('b')` | `->where('a', 'b')` |
| `->fetchOne()` | `->first()` |
| `$this->request` in `addItem()` | Use `modifyAddItem($data, $request)` hook |
| Override `addItem()` for route params | Use `modifyAddItem()` or override `add()` |
| `protected function modifyAddItem()` | `protected function modifyAddItem()` (typo) |
| `\Modules\User\Models\User::get()` | `use Modules\User\Models\User; User::get()` |
| `$factory = 'Modules\\Post\\...\\PostFactory';` | `use ...\PostFactory; $factory = PostFactory::class;` |
| `$request->route('id')` | `$request->getInt('id')` or `$request->input('id')` |
| `if (!$userId) return error()` in controller | Remove check - policy handles auth |
| `$userId = session()->user->id ?? null;` | `$userId = session()->user->id;` after policy |
| `throw new \Exception()` in controller | `$this->setError()` or `$this->error()` |
| `$m = new Model(); $m->x = 1; $m->add();` | `$m = new Model((object)['x' => 1]); $m->add();` |
| `$builder->belongsTo(Org::class, ['name'])` | `$builder->belongsTo(Org::class, fields: ['name'])` |
| `Role::one($builder)->on(['roleId', 'id'])` | `Role::one($builder)->on(['id', 'userId'])` (parent first) |
| `$builder->belongsTo(Org::class, fields: ['id', 'name'])` | Exclude 'id': `fields: ['name']` |
| `return $this->hasMany(Post::class)` in `joins()` | Use JoinBuilder methods in `joins()` |
| `Post::one($this)->fields('title')` outside `joins()` | Use lazy relationships: `hasMany()` |
| `CreateEventsTable.php` migration filename | `2026-01-21T04.14.30.800125_Event.php` |
| `class CreateEventsTable extends Migration` | Class name must match filename after underscore: `class Event` |
| `$this->faker->email()` in factory | `$this->faker()->email()` (method call not property) |
| `$this->faker->latitude(25, 50)` | `$this->faker()->floatBetween(25.0, 50.0, 6)` |
| `$this->faker->longitude(-125, -65)` | `$this->faker()->floatBetween(-125.0, -65.0, 6)` |
| `$this->faker->optional(0.7)->value` | `$this->faker()->boolean(70) ? value : null` |
| `$this->faker->randomFloat(2, 10, 100)` | `$this->faker()->floatBetween(10.0, 100.0, 2)` |
| `$this->faker->paragraphs(3, true)` | `$this->faker()->paragraph(3)` |
| `$this->faker->dateTimeThisMonth()` | `$this->faker()->dateTimeBetween('-1 month', 'now')` |
| Manual POINT handling in Storage | Use `$dataTypes = ['position' => PointType::class]` in model |
| Custom Storage for JSON encoding | Use `$dataTypes = ['metadata' => JsonType::class]` in model |
| `$location->position = 'lat,lon'` (comma) | `$location->position = 'lat lon'` (space) or array `[lat, lon]` |
| `$_FILES['upload']` in controller | `$request->file('upload')` |
| `new UploadFile($_FILES['upload'])` | `$request->file('upload')` or `$request->validateFile('upload', [...])` |

### Frontend (Base)

| ❌ WRONG | ✅ CORRECT |
|---------|-----------|
| `Div({ children: [...] })` | `Div({}, [...])` |
| `Ul([items.map(...)])` | `Ul({ map: [items, ...] })` or `Ul({ for: ['items', ...] })` |
| `new Button()` | `Button()` (Atoms don't use `new`) |
| `Icon(Icons.home)` | `Icon({ size: 'sm' }, Icons.home)` |
| `Import('./file.js')` | `Import(() => import('./file.js'))` |
| `Icon({ icon: Icons.home })` | `Icon({ size: 'sm' }, Icons.home)` |
| `class: 'text-white bg-black'` | `class: 'text-foreground bg-surface'` |
| `class: 'text-blue-500'` | `class: 'text-primary'` |
| `class: 'border-gray-300'` | `class: 'border-border'` |
| `import { MaterialIcon } from '@components/material-icon.js'` | `import { MaterialIcon, UniversalIcon } from '@base-framework/ui/atoms'` |
| `import { MaterialIcons } from '@components/material-icon.js'` | `import { MaterialSymbols } from '@base-framework/ui/icons'` |
| `MaterialIcon({ icon: 'home' })` | `MaterialIcon({ name: 'home', size: 'sm' })` (use `name` not `icon`) |
| `UniversalIcon('home')` | `UniversalIcon({ size: 'sm' }, 'home')` (icon is 2nd arg) |
| `export class Page extends Component {` | `export class Page extends Component\n{` (brace on new line) |
| `render() {` | `render()\n{` (brace on new line) |
| `const data = new Data({})` | `const data = new Data({});` (semicolon required) |
| Module not in `imported-modules.js` | Add `import "./module/module.js";` |
| Files in `src/modules/home/` | Organize: `src/modules/home/components/pages/home/` |
| Custom button without Base UI | Use `Button` from `@base-framework/ui/atoms` first |

## 6. Testing (Backend)

The Proto test framework extends PHPUnit and provides helpers for database assertions and test setup. There are a few traits applied to the base Test class that provide common functionality. Check the Proto composer module `src\Tests\Test` class for details.
### Test Structure

```php
<?php declare(strict_types=1);

namespace Modules\User\Tests\Feature;

use Proto\Tests\Test;
use Modules\User\Models\User;

class UserTest extends Test
{
    public function testCreateUser(): void
    {
        $user = new User();
        $user->name = 'John';
        $user->email = 'john@example.com';
        $user->add();

        $this->assertDatabaseHas('users', [
            'name' => 'John',
            'email' => 'john@example.com'
        ]);
    }
}
```

### Test Helpers

**Creating Test Data**:
```php
// Use factories for model creation
protected function createUser(): User
{
    return User::factory()->create([
        'username' => 'testuser' . uniqid(),
        'email' => 'test' . uniqid() . '@example.com'
    ]);
}

// Or manual instantiation (ensure all required fields)
protected function createUser(): User
{
    $user = new User((object)[
        'username' => 'testuser' . uniqid(),
        'email' => 'test' . uniqid() . '@example.com',
        'password' => password_hash('password123', PASSWORD_DEFAULT),
        'firstName' => 'Test',
        'lastName' => 'User',
        'status' => 'offline'
    ]);
    $user->add();

    if (!$user->id)
    {
        throw new \Exception('Failed to create test user');
    }

    return $user;
}
```

### Patterns

**Factories**:
```php
User::factory()->create();           // Persisted
User::factory()->make();             // Unpersisted
User::factory()->count(5)->create(); // Bulk
User::factory()->create(['email' => 'specific@example.com']); // Custom attributes
```

**Assertions**:
```php
$this->assertDatabaseHas('table', [...]);
$this->assertDatabaseMissing('table', [...]);
$this->assertDatabaseCount('table', 5);
$this->assertTrue($condition);
$this->assertEquals($expected, $actual);
$this->assertNotNull($value);
$this->assertIsArray($value);
```

### Test Transactions

**How It Works**:
- Tests auto-wrap in transactions and rollback automatically
- Connection caching ensures all operations share the same connection/transaction
- Proto framework automatically uses `Database::getConnection($connection, true)` to cache connections
- All model methods (`Model::get()`, `Model::getBy()`, `Model::fetchWhere()`) work correctly within test transactions

**Best Practices**:
```php
// ✅ All these patterns work correctly
$user = User::factory()->create();

// Direct assertion (preferred for verification)
$this->assertDatabaseHas('users', ['id' => $user->id, 'email' => $user->email]);

// Re-fetch with Model::get() (works correctly)
$fetched = User::get($user->id);
$this->assertNotNull($fetched);

// Re-fetch with Model::getBy() (works correctly)
$fetched = User::getBy(['id' => $user->id]);
$this->assertNotNull($fetched);

// Use returned object directly
$this->assertEquals('test@example.com', $user->email);
```

**Important Notes**:
- Connection caching is enabled automatically in tests (`dbCaching=true`)
- Don't disable foreign key checks unless absolutely necessary
- Don't manually create separate database connections (use Proto's connection methods)

### Models with Eager Joins - Testing Considerations

**CRITICAL**: Models that use eager joins (via `joins()` method with `belongsTo()`, `belongsToMany()`, etc.) have a known limitation when re-fetching data within the same test transaction. The joins create separate queries that may not see uncommitted data.

**Affected Models**: Any model with a `joins()` method that uses JoinBuilder (e.g., Partner, PartnerBooking, PartnerLead with User/Partner joins)

**Testing Patterns for Models with Eager Joins**:

```php
// ✅ CORRECT - Use original object returned by factory
$booking = PartnerBooking::factory()->create(['confirmationCode' => 'ABC123']);
$this->assertNotNull($booking->id);
$this->assertEquals('ABC123', $booking->confirmationCode);

// ✅ CORRECT - Verify via database assertion
$this->assertDatabaseHas('partner_bookings', [
    'id' => $booking->id,
    'confirmationCode' => 'ABC123'
]);

// ❌ WRONG - Re-fetching may return null for models with eager joins
$fetched = PartnerBooking::get($booking->id); // May be null!
$this->assertNotNull($fetched); // May fail

// ❌ WRONG - Custom query methods may also fail
$fetched = PartnerBooking::getByConfirmationCode('ABC123'); // May be null!
```

**Writing Update Methods for Models with Eager Joins**:

```php
// ❌ WRONG - Fetch-then-update pattern fails in tests
public static function markResponded(int $leadId): bool
{
    $lead = static::get($leadId); // Returns null in test!
    if (!$lead) return false;

    $lead->status = 'contacted';
    return $lead->update();
}

// ✅ CORRECT - Use query builder directly
public static function markResponded(int $leadId): bool
{
    return static::builder()
        ->update()
        ->set(['status' => 'contacted', 'responded_at' => date('Y-m-d H:i:s')])
        ->where('id = ?')
        ->execute([$leadId]);
}
```

**Service Methods and Testing**:

```php
// ❌ WRONG - Service method that fetches model fails in tests
public function submitLead(int $partnerId, int $userId, object $data): object|false
{
    $partner = Partner::get($partnerId); // Returns null in test!
    if (!$partner) return false;
    // ...
}

// ✅ CORRECT - Test the behavior without calling service method
public function testSubmitLead(): void
{
    $partner = Partner::factory()->create();

    // Create lead directly instead of via service
    $lead = PartnerLead::factory()->create([
        'partnerId' => $partner->id,
        'userId' => $user->id,
        'status' => 'new'
    ]);

    // Verify via database assertion
    $this->assertDatabaseHas('partner_leads', [
        'id' => $lead->id,
        'status' => 'new'
    ]);
}
```

**Field Naming in Tests**:

```php
// ❌ WRONG - Using snake_case
$this->assertEquals('pending', $partner->verification_status);
$this->assertEquals($user->id, $booking->user_id);

// ✅ CORRECT - Always use camelCase
$this->assertEquals('pending', $partner->verificationStatus);
$this->assertEquals($user->id, $booking->userId);

// ✅ CORRECT - Database assertions use camelCase too
$this->assertDatabaseHas('partners', [
    'id' => $partner->id,
    'verificationStatus' => 'pending'
]);
```

**Summary - Testing Models with Eager Joins**:
1. Use the object returned by `factory()->create()` directly
2. Verify persistence with `assertDatabaseHas()` instead of re-fetching
3. Write static update methods using query builder, not fetch-then-update
4. In tests, create models directly instead of calling service methods that fetch
5. Always use camelCase for field names, both in code and database assertions

## 7. Configuration

**Location**: `common/Config/.env` (JSON format)

**Access**: `env('key')` or `env('key.nested')`

**Docker Sync**: `./infrastructure/scripts/run.sh sync-config`

## 8. Events & Dispatch System

### Events

Proto provides a powerful event system for decoupled communication between application components.

**Event Types**:
- **Local Events**: In-process events using PubSub pattern
- **Redis Events**: Distributed events across multiple instances via Redis pub/sub
- **Storage Events**: Automatically triggered by model CRUD operations
- **Custom Events**: Manually triggered for application-specific logic

**Basic Usage**:
```php
use Proto\Events\Events;

// Subscribe to an event
Events::on('user.created', function($payload) {
    // Handle the event
    EmailService::sendWelcome($payload->email);
});

// Publish an event
Events::update('user.created', (object)[
    'id' => $userId,
    'email' => $email
]);

// Helper function syntax
events()->subscribe('user.created', $callback);
events()->emit('user.created', $data);
```

**Redis Events (Distributed)**:
Prefix event names with `redis:` to broadcast across all application instances:
```php
// Subscribe on ALL instances
Events::on('redis:cache.cleared', function($data) {
    Logger::info('Cache cleared globally');
});

// Publish to ALL instances
Events::update('redis:cache.cleared', ['timestamp' => time()]);
```

**Storage Events**:
The storage layer automatically publishes events for CRUD operations:
```php
// Listen for model add operations
Events::on('User:add', function($payload) {
    // $payload contains: args, data
});

// Listen to ALL storage events
Events::on('Storage', function($payload) {
    // $payload contains: target (model name), method, data
});
```

**Server-Sent Events (SSE)**:
For real-time streaming to clients:
```php
public function stream(Request $request): void
{
    $channel = "conversation:{$conversationId}:messages";
    redisEvent($channel, function($channel, $message): array|null
    {
        $messageId = $message['id'] ?? null;
        if (!$messageId) return null;

        $messageData = Message::get($messageId);
        return ['merge' => [$messageData], 'deleted' => []];
    });
}
```

### Dispatch (Email, SMS, Push Notifications)

**Location**: `Proto\Dispatch\Dispatcher` and `Proto\Dispatch\Enqueuer`

**Email**:
```php
use Proto\Dispatch\Dispatcher;
use Proto\Dispatch\Enqueuer;

$settings = (object)[
    'to' => 'email@example.com',
    'subject' => 'Welcome',
    'fromName' => 'App Name',
    'template' => 'Common\\Email\\WelcomeEmail',
    'attachments' => ['/path/to/file.pdf']
];

$data = (object)['name' => 'John'];

// Send immediately
Dispatcher::email($settings, $data);

// Enqueue for later
Enqueuer::email($settings, $data);

// Or use queue flag
$settings->queue = true;
Dispatcher::email($settings, $data);
```

**SMS (Twilio)**:
```php
$settings = (object)[
    'to' => '1112221111',
    'template' => 'Common\\Text\\NotificationSms'
];

Dispatcher::sms($settings, $data);
Enqueuer::sms($settings, $data);
```

**Web Push (VAPID)**:
```php
$settings = (object)[
    'subscriptions' => [
        [
            'endpoint' => 'https://...',
            'keys' => ['auth' => '...', 'p256dh' => '...']
        ]
    ],
    'template' => 'Common\\Push\\NotificationPush'
];

Dispatcher::push($settings, $data);
```

**User Module Gateways** (recommended for user notifications):
```php
// Email to user
modules()->user()->email()->sendById($userId, $settings, $data);
modules()->user()->email()->send($user, $settings, $data);

// SMS to user
modules()->user()->sms()->sendById($userId, $settings, $data);

// Push to user
modules()->user()->push()->send($userId, $settings, $data);
```

## 9. Integration Points

- **Database**: MariaDB (port 3307 on host)
- **Cache**: Redis (port 6380 on host)
- **Email**: SMTP settings from `common/Config/.env`
- **Frontend**: Proxies `/api` to backend via Vite config

## 10. Quick References

### Add New Feature

**Backend (Flat Module)**:
1. Create controller: `modules/Feature/Controllers/FeatureController.php`
2. Register routes: `modules/Feature/Api/api.php`
   - **Nested API folders supported**: `modules/Feature/Api/Subfeature/api.php`
3. Add migrations: `modules/Feature/Migrations/*`
4. Add tests: `modules/Feature/Tests/Feature/*Test.php`

**Backend (Nested Feature Module)**:
1. Create feature directory: `modules/ParentModule/Feature/`
2. Add controller: `modules/ParentModule/Feature/Controllers/FeatureController.php`
3. Register routes: `modules/ParentModule/Feature/Api/api.php` → `/api/parentmodule/feature`
4. Add migrations: `modules/ParentModule/Feature/Migrations/*`
5. Add gateway method to parent: `modules/ParentModule/Gateway/Gateway.php`
6. Use Main folder if parent needs root-level routes: `modules/ParentModule/Main/Api/api.php`

**Frontend**:
1. Create the frontend Module if not already available: `apps/{crm|main}/src/modules/{moduleName}/module.js`
```js
import { Icons } from "@base-framework/ui/icons";
import { Module } from '../module/module.js';

/**
 * This will set the routes for the module.
 *
 * @type {Array<object>} routes
 */
const routes = Module.convertRoutes(
[
    { path: '/', import: () => import('./components/pages/home/home-page.js'), title: 'Home' }
]);

/**
 * This will set the links for the module.
 *
 * @type {Array<object>} links
 */
const links =
[
    { label: 'Home', href: './', icon: Icons.home, mobileOrder: 1, exact: true }
];

/**
 * This will create our module and add it to the app
 * modules.
 */
Module.create(
{
    /**
     * @param {Array<object>} routes
     */
    routes,

    /**
     * This will get the options to create the app
     * navigation.
     *
     * @param {Array<object>} links
     */
    links
});
```
2. Create components including pages, atoms, etc. for the feature: `apps/{crm|main}/src/modules/{moduleName}/components/pages/{feature}/{pageName}-page.js`
3. Create the necessary Models that extends the base Model to connect the data to the api. Models include default actions like add, update, setup, all, get, delete (relative paths - Vite proxy handles routing)

the all method can select a list of items from the api, get method can get a single item by id, add method to create a new item, update method to update an existing item, delete method to remove an item.

```js
import { Model } from "@base-framework/base";
import { Icons } from "@base-framework/ui/icons";

/**
 * ConversationModel
 *
 * This model handles client conversation operations.
 *
 * @type {typeof Model}
 */
export const ConversationModel = Model.extend({
    /**
     * Base URL for conversation endpoints.
     * Will be completed with clientId in the component.
     */
    url: '/api/client/[[clientId]]/conversation',

    xhr: {
        /**
         * Synchronize conversations in real-time using EventSource.
         *
         * @param {object} instanceParams - The instance parameters.
         * @param {function} callBack - The callback function for incoming updates.
         * @param {function} onOpenCallBack - Optional callback when connection opens.
         * @returns {object} Object with source and cleanup function
         */
        sync(instanceParams, callBack, onOpenCallBack)
        {
            const lastId = instanceParams?.lastId || 0;
            const params = lastId ? `lastId=${lastId}` : '';
            return this.setupEventSource('/sync', params, callBack, onOpenCallBack);
        },

        addFiles(data, formData)
        {
            Object.keys(data).forEach(key =>
            {
                if (key !== 'attachments')
                {
                    formData.append(key, data[key]);
                }
            });

            // Add files
            Array.from(files).forEach(file =>
            {
                // Validate file size (10MB as per backend validation)
                const maxSize = 10 * 1024 * 1024; // 10MB
                if (file.size > maxSize)
                {
                    app.notify({
                        type: "destructive",
                        title: "File Too Large",
                        description: `${file.name} exceeds 10MB limit.`,
                        icon: Icons.warning
                    });
                    return;
                }

                formData.append('attachments[]', file);
            });
        },

        /**
         * Add a new conversation message with optional file attachments.
         *
         * @param {object} instanceParams - The instance parameters.
         * @param {function} callBack - The callback function.
         * @param {FileList|File[]} [files] - Optional files to attach.
         * @returns {XMLHttpRequest|void} The request promise.
         */
        add(instanceParams, callBack, files)
        {
            const data = this.model.get();
            const url = (typeof data.id === 'undefined')? '' : `/${data.id}`;

            // If no files, send as JSON (exclude attachments field)
            if (!files || files.length === 0)
            {
                const cleanData = { ...data };
                delete cleanData.attachments;
                const params = this.setupObjectData(cleanData);
                return this._post(url, params, instanceParams, callBack);
            }

            // With files, use FormData
            const formData = new FormData();
            this.addFiles(data, formData);

            return this._post(url, formData, instanceParams, callBack);
        },

        update(instanceParams, callBack)
        {
            let params = this.setupObjectData();
            const id = this.model.id;
            const url = (typeof id === 'undefined')? '' : `/${id}`;

            return this._patch(url, params, instanceParams, callBack);
        },

        verifyEmail(instanceParams, callBack)
        {
            const data = this.model.get();
            let params = {
                token: instanceParams.token
            };

            return this._patch(`${data.id}/verify-email`, params, instanceParams, callBack);
        }
    }
});
```
4. Import module in module-imports.js to add the new module to the platform: `apps/{crm|main}/src/modules/imported-modules.js`

### Key Files

- Backend boot: `public/api/index.php`
- Docker config: `infrastructure/docker-compose.yaml`
- Migrations runner: `infrastructure/scripts/run-migrations.php`
- Frontend proxy: `apps/*/vite.config.js`
- Domain config: `infrastructure/config/domain.config.js`
- Config flow: `common/Config/.env` (JSON) → `infrastructure/scripts/sync-config.js` → root `.env`

### Debugging & Gotchas

**Docker Issues**:
- If `vendor/` missing: Container runs `composer install` automatically. Check: `docker-compose logs -f web`
- Auto-migrations: Disable for production with `AUTO_MIGRATE=false`

**CORS Issues**:
- Origins from `sync-config.js` using dev ports in `common/Config/.env`
- Update JSON config and run `./infrastructure/scripts/run.sh sync-config`

**Frontend API Calls**:
- Always use relative paths: `/api/...` (Vite proxy resolves host)
- DON'T hardcode domains - proxy handles environment

**Database Ports**:
- MariaDB: Host port 3307 (container port 3306)
- Redis: Host port 6380 (container port 6379)
