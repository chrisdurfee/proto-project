# Copilot Instructions for Proto Project

Use these repo-specific rules to be productive immediately.

## Big picture
- Backend: PHP 8.2+/8.3 monolith using Proto Framework. Entry: `public/api/index.php` boots `Proto\Api\ApiRouter::initialize()`.
- Code layout: `modules/*` (feature modules), `common/*` (shared framework glue), `public/*` (HTTP entrypoints/assets).
- Autoloading: PSR-4 maps `Modules\` → `modules/`, `Common\` → `common/` (see `composer.json`). Migrations are classmapped from `common/Migrations` and `modules/*/Migrations`.
- Frontend: Three Vite apps in `apps/{main,crm,developer}` using Base Framework UI libs. Each proxies `/api` to the backend based on `infrastructure/config/domain.config.js`.
- Infra: `docker-compose.yaml` runs `web` (php-apache), `mariadb`, `redis`. Container entrypoint installs deps if missing and (optionally) runs DB migrations.

## Critical workflows
- One-time config: copy JSON env and sync to Docker
  - `common/Config/.env-example` → `common/Config/.env`
  - `./run.sh sync-config` generates root `.env` for Docker from JSON config
- Start services: `docker-compose up -d` (auto-migrations by default via `AUTO_MIGRATE=true`)
  - Logs: `docker-compose logs -f web` • Shell: `docker-compose exec web bash`
  - Manual migrations: `docker-compose exec web php infrastructure/scripts/run-migrations.php`
- Frontend dev: in each app, `npm install` then `npm run dev` (ports 3000/3001/3002; `/api` is proxied to the container at 8080)
- Tests: run inside the `web` container. Suites are defined in `phpunit.xml`:
  - Unit: `common/Tests/Unit` • Feature: `common/Tests/Feature`, `modules/*/Tests/Feature` • Module tests under `modules/**`

## Conventions and patterns
- Configuration is JSON in `common/Config/.env`. Access in PHP via Proto Config helpers (e.g., `env('siteName')`).
- Routes live in module API registries. Example (`modules/YourFeature/Api/api.php`):
  - `router()->resource('feature', Modules\YourFeature\Controllers\FeatureController::class);`
- Services extend `Common\Services\Service`. Use `Common\Data` (a `Proto\Patterns\Structural\Registry` singleton) for shared app state when needed.
- Migrations are PHP classes under `common/Migrations` or `modules/*/Migrations`. They’re executed by `infrastructure/scripts/run-migrations.php` (entrypoint runs them when `AUTO_MIGRATE=true`).
- Files: writable volumes are mounted at `public/files` and `common/files` (see `docker-compose.yaml`).

## Proto coding patterns (AI quick recipes)
- Controllers
  - Extend `Proto\Controllers\ResourceController` for CRUD or `ApiController` for custom endpoints.
  - Bind a model: `class UserController extends ResourceController { public function __construct(protected ?string $model = User::class){ parent::__construct(); } }`
  - Helpers: `$this->getRequestItem(Request)`, `$this->getResourceId(Request)`, `$this->response($data)`, `$this->error($message)`.
  - Validation: implement `protected function validate(): array` or call `$this->validateRules($data, ['name' => 'string:255|required'])` or `$request->validate([...])`.
  - Pass-through: public methods on the model (and its storage) are auto-wrapped in a Response when invoked via the controller.
- Routing
  - Register in `modules/*/Api/api.php`: `router()->resource('users', Modules\User\Controllers\UserController::class);`
  - Add custom routes to controller methods as needed via the module router.
- Query patterns
  - Simple: `User::getBy(['name' => $name])`, `User::fetchWhere(['status' => 'active'])`.
  - Builder: `User::where(['name' => $name])->orderBy('id DESC')->groupBy('id')->fetch();`
  - Storage closures: `$this->storage()->findAll(fn($sql,&$p)=>($p[]='active',$sql->where('status = ?')->orderBy('status DESC')));`
- Validation rules
  - Format: `'type[:max]|required'` (e.g., `'string:255|required'`, `'email|required'`, `'int|required'`).
  - Common types: `int,float,string,email,ip,phone,mac,bool,url,domain`.
- Migrations
  - Place classes under `common/Migrations` or `modules/*/Migrations`; executed by the migration runner.
  - From docs: `Proto\Database\Migrations\Guide` supports `run()` and `revert()` when invoked from scripts.
- File storage
  - Use `Proto\Utils\Files\Vault` (see Developer app docs) for storing/retrieving files; buckets map to `public/files` or remote drivers.

## Integration points
- Database: MariaDB (port 3307 on host). Config is sourced from `common/Config/.env` via `sync-config.js`.
- Cache: Redis (port 6380 on host). Env is generated by `sync-config.js` from `cache.connection`.
- Email: SMTP settings populated from `common/Config/.env` (`email.smtp.*`). See `common/Email/*` and `common/Services/EmailService.php`.
- Frontend URLs: `infrastructure/config/domain.config.js` exposes `generateUrls(isDev)` used by each `vite.config.js` to set proxy targets.

## Adding features (fast path)
- Backend API:
  - Create controller in `modules/Feature/Controllers/...`
  - Register routes in `modules/Feature/Api/api.php` (use `router()->resource(...)` or custom routes)
  - Add migrations in `modules/Feature/Migrations/*`
  - Tests in `modules/Feature/Tests/{Unit,Feature}/*Test.php`
- Frontend:
  - Call the API with relative paths (`/api/...`); Vite proxy resolves the host automatically.
  - Don’t hardcode domains—derive via `generateUrls` in `vite.config.js` if needed.

## Debugging and gotchas
- If `vendor/` isn’t present due to bind mounts, the container entrypoint runs `composer install` automatically. Check `docker-compose logs -f web`.
- Disable auto-migrations for production by setting `AUTO_MIGRATE=false` (then run the migration script manually).
- CORS origins come from `sync-config.js` using dev ports in `common/Config/.env`. Update that JSON and resync if browser requests are blocked.

Key files to orient quickly:
- Backend boot: `public/api/index.php`, `Dockerfile`, `infrastructure/docker/entrypoint.sh`
- Config flow: `common/Config/.env` (JSON) → `sync-config.js` → root `.env` used by `docker-compose.yaml`
- Frontend proxy: each `apps/*/vite.config.js` + `infrastructure/config/domain.config.js`

## Base Framework (frontend) patterns
- Atoms (building blocks)
  - Create with functions or `Atom((props, children)=>({...}))`; compose by nesting children.
  - Events receive `(event, parentComponent)`; e.g., `click: (e, parent)=>{ /* use parent */ }`.
  - Usage overloads: `Div(props)`, `Div('text')`, `Div([child1, child2])`, or `Div(props, children)`.
  - Typical pattern (copy-to-clipboard): `Code({ click:()=>{ navigator.clipboard.writeText(...); app.notify({ title:'Code copied', icon: Icons.clipboard.checked }); } }, children)`.
- Components (containers)
  - Class-based components define `render()` and can use lifecycle hooks like `afterSetup()`.
  - Scoped: atoms inherit parent component scope (state, data, directives). Routed components get `this.route` injected.
- Data (aka jots/bindables)
  - Bindable data via `new Data({...})` (deep) or `new SimpleData({...})` (shallow). Get/set with proxy or methods (`data.name`, `data.set({...})`).
  - Helpers: `increment`, `decrement`, `toggle`, `scope(path)`, array ops (`push`, `splice`, `unshift`, `shift`, `pop`), `refresh`, `revert`.
  - Local storage: `data.setKey('KEY'); data.resume(defaults); data.store();`
- Directives (power-ups)
  - Binding: `bind: 'prop'` or `bind: ['prop', filterOrFn]`; bind attribute: `bind: 'href:prop'`.
  - Watchers: string placeholders `[[prop]]` in attributes or `{ watch: {...} }` for custom attr/callback.
  - Reactive: `onSet: ['prop', fn]` and `onState: ['state', fn]` to update layout/classes.
  - Routing: `route: { uri, component|import, title, persist? }` or an array; `switch: [...]` renders first match.
  - Cache elements: `{ cache: 'propertyName' }` then use `this.propertyName` in parent after render.
  - Lifecycle callbacks: `{ onCreated(ele, parent){...}, onDestroyed(ele){...}, debug:true }`.
  - Context: `{ context: (ctx)=>({ text: ctx.data.name }) }` to pass data down without props.
  - Mapping: `{ map: [items, (item,i)=> new Item(item)] }` or `for: ['prop', (item,i,scoped)=> ... ]` for bindable arrays.
  - Dataset/ARIA/ID: `{ dataSet:[...], aria:{...}, getId:'prop' }`.
  - Custom directives: `Directives.add('name', (ele, data, parent)=>{ /* ... */ })`.
- Special atoms
  - Conditional children: `On('prop', (v)=> v? ViewA(): ViewB())`, `OnState('state', fn)`, `OnRoute('prop', fn)`.
  - Access parent: `UseParent((parent)=> Div({ class: parent.state.loaded? 'loaded':'loading' }))`.
- Icons and notifications
  - `Icons` from `@base-framework/ui/icons`; global notify via `app.notify({ title, description, icon: Icons.circleCheck })`.
- Project wiring
  - Aliases in `vite.config.js`: `@components`, `@pages`, `@modules`, `@shell`. Dev servers proxy `/api` using `generateUrls(isDev)`.
  - Environment: use relative `/api/...`; Developer app exposes `process.env.VITE_API_URL`.
  - Styling: Tailwind via `@tailwindcss/vite`; pass class strings directly via `class` prop.

